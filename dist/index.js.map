{"version":3,"sources":["webpack://vue-infinite-grid/webpack/universalModuleDefinition","webpack://vue-infinite-grid/webpack/bootstrap","webpack://vue-infinite-grid/./node_modules/@egjs/infinitegrid/src/layouts/lib/BoxModel.js","webpack://vue-infinite-grid/./node_modules/@egjs/infinitegrid/src/layouts/lib/dijkstra.js","webpack://vue-infinite-grid/./node_modules/@egjs/component/dist/component.js","webpack://vue-infinite-grid/./node_modules/@egjs/infinitegrid/src/browser.js","webpack://vue-infinite-grid/./node_modules/@egjs/infinitegrid/src/consts.js","webpack://vue-infinite-grid/./node_modules/@egjs/infinitegrid/src/utils.js","webpack://vue-infinite-grid/./node_modules/@egjs/infinitegrid/src/DOMRenderer.js","webpack://vue-infinite-grid/./node_modules/@egjs/infinitegrid/src/ItemManager.js","webpack://vue-infinite-grid/./node_modules/@egjs/infinitegrid/src/AutoSizer.js","webpack://vue-infinite-grid/./node_modules/@egjs/infinitegrid/src/ImageLoaded.js","webpack://vue-infinite-grid/./node_modules/@egjs/infinitegrid/src/Watcher.js","webpack://vue-infinite-grid/./node_modules/@egjs/infinitegrid/src/InfiniteGrid.js","webpack://vue-infinite-grid/./node_modules/@egjs/infinitegrid/src/layouts/GridLayout.js","webpack://vue-infinite-grid/./node_modules/@egjs/infinitegrid/src/layouts/FrameLayout.js","webpack://vue-infinite-grid/./node_modules/@egjs/infinitegrid/src/layouts/SquareLayout.js","webpack://vue-infinite-grid/./node_modules/@egjs/infinitegrid/src/layouts/PackingLayout.js","webpack://vue-infinite-grid/./node_modules/@egjs/infinitegrid/src/layouts/JustifiedLayout.js","webpack://vue-infinite-grid/./node_modules/@egjs/infinitegrid/src/index.js","webpack://vue-infinite-grid/./src/VueInfiniteGrid.vue","webpack://vue-infinite-grid/./node_modules/vue-loader/lib/runtime/component-normalizer.js","webpack://vue-infinite-grid/src/VueInfiniteGrid.vue","webpack://vue-infinite-grid/./src/VueInfiniteGrid.vue?2229","webpack://vue-infinite-grid/./src/index.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","[object Object]","option","this","_originWidth","originWidth","_originHeight","originHeight","_width","width","_height","height","_left","left","_top","top","_item","item","_innerItem","innerItem","scaleX","scaleY","forEach","v","push","box","dijkstra","single_source_shortest_paths","graph","predecessors","costs","closest","u","cost_of_s_to_u","adjacent_nodes","cost_of_s_to_u_plus_cost_of_e","cost_of_s_to_v","open","BinaryHeap","x","cost","size","pop","msg","join","Error","extract_shortest_path_from_predecessor_list","nodes","reverse","find_path","scoreFunction","content","element","bubbleUp","length","result","end","sinkDown","remove","node","len","parentN","Math","floor","parent","elemScore","child2N","child1N","swap","child1","child1Score","child2","obj","_Component","_Component2","default","VERSION","_typeof","Symbol","iterator","constructor","Component","instance","Constructor","TypeError","_classCallCheck","_eventHandler","options","trigger","eventName","customEvent","arguments","undefined","handlerList","concat","eventType","isCanceled","arg","stop","currentTarget","_len","restParam","Array","_key","apply","once","handlerToAttach","eventHash","self","on","listener","_len2","_key2","off","hasOn","handlerToDetach","k","handlerFunction","splice","win","browser_document","document","consts_ua","navigator","userAgent","consts_SUPPORT_COMPUTEDSTYLE","consts_SUPPORT_ADDEVENTLISTENER","consts_SUPPORT_PASSIVE","supportsPassiveOption","addEventListener","e","consts_IS_IE","test","consts_IS_IOS","consts_IS_ANDROID2","consts_CONTAINER_CLASSNAME","consts_IGNORE_CLASSNAME","consts_APPEND","consts_PREPEND","consts_VERTICAL","consts_HORIZONTAL","consts_CACHE","consts_NO_CACHE","consts_TRUSTED","consts_NO_TRUSTED","consts_MULTI","consts_DUMMY_POSITION","consts_GROUPKEY_ATT","consts_DEFAULT_OPTIONS","horizontal","margin","consts_agent","toLowerCase","consts_IDLE","consts_LOADING_APPEND","consts_LOADING_PREPEND","consts_PROCESSING","consts_webkit","exec","consts_WEBKIT_VERSION","parseInt","consts_DEFENSE_BROWSER","utils_toArray","array","utils_matchHTML","html","match","utils_$","param","multi","el","dummy","createElement","innerHTML","childNodes","querySelectorAll","nodeName","nodeType","jQuery","jquery","toArray","isArray","map","utils_addEvent","type","handler","eventListenerOptions","attachEvent","utils_removeEvent","removeEventListener","detachEvent","utils_getStyles","getComputedStyle","currentStyle","utils_getSize","documentElement","doc","max","body","style","parseFloat","utils_innerWidth","utils_innerHeight","utils_STYLE","vertical","pos1","endPos1","size1","pos2","endPos2","size2","utils_getStyleNames","isHorizontal","utils_assignOptions","defaultOptions","assign","utils_fill","arr","DOMRenderer_DOMRenderer","styles","elStyle","setAttribute","groupKey","position","items","renderItem","rect","removeElement","parentNode","removeChild","elements","reduce","acc","replace","index","isOverflowScroll","isEqualSize","isVertical","_size","containerOffset","container","view","_init","resize","cssText","status","renderItems","_insert","orgSize","_orgStyle","target","overflowX","overflowY","className","children","appendChild","DOMRenderer_defense","viewport","isAppend","itemsWithElement","createElements","df","createDocumentFragment","insertBefore","firstChild","point","pos","y","scrollBy","scrollLeft","scrollTop","utils_scrollBy","isNeededResize","_calcSize","ItemManager_ItemManager","selector","selectItems","outerHTML","filter","classNames","split","some","data","clear","_data","item2","data2","start","set","base","outlines","pluck","slice","cursor","prop","targetValue","Infinity","getOutline","dataIdx","getEdgeIndex","itemIdx","layouted","unshift","key","getAttribute","String","idx","AutoSizer_elements","AutoSizer_onResize","AutoSizer_AutoSizer","resizeAll","prefix","__PREFIX__","isFixed","fixed","indexOf","elementPrefix","dataWidth","dataHeight","ImageLoaded_CHECK_ALL","ImageLoaded_CHECK_ONLY_ERROR","ImageLoaded_errorImages","ImageLoaded_isDataAttribute","src_ImageLoaded","needCheck","complete","error","checkCount","endCount","sum","checkEnd","checkImage","onError","itemIndex","__ITEM_INDEX__","onCheck","srcElement","src","images","add","tagName","checkImageLoaded","setTimeout","waitImageLoaded","Watcher_Watcher","renderer","callback","_callback","layout","check","_timer","reset","_renderer","_onCheck","bind","_onResize","setScrollPos","_prevPos","scrollPos","getOrgScrollPos","applyScrollPos","scrollTo","arrPos","scroll","utils_scrollTo","rawPos","getContainerOffset","utils_scroll","prevPos","getScrollPos","orgScrollPos","isForward","clearTimeout","InfiniteGrid_hasTarget","targets","every","create","properties","F","InfiniteGrid_InfiniteGrid","component_default","a","super","itemSelector","threshold","useRecycle","attributePrefix","_isVertical","_reset","_items","_loadingBar","_watcher","_layout","LayoutKlass","setSize","getViewportSize","includeCached","_status","startCursor","endCursor","getEdge","bottom","right","scrollCycle","_getEdgeValue","_getLoadingStatus","loadingSize","abs","fit","_getVisibleItems","setContainerSize","isProcessing","_isProcessing","_process","getEdgeValue","isRelayout","outline","updateSize","_fit","group","_onLayoutComplete","getStatus","setStatus","_updateEdge","_appendLoadingBar","userLoadingBar","loadingBarObj","append","prepend","loadingStyle","loadingBar","_isLoading","processingStatus","isAdd","Date","getTime","random","from","_postLayout","_isVisible","lastIndexOf","removeItems","userStyle","display","_renderLoading","fromCache","isTrusted","_setItems","_insertItems","_updateCursor","removeTarget","replaceTarget","removeItem","removeAttribute","replaceItem","_recycle","layoutedItems","fromRelayout","cacheOutline","createAndInsert","method","_postImageLoaded","_onImageError","_postImageLoadedEnd","min","getViewSize","_getNextItems","getGroupKeys","shift","_getEdgeOffset","targetPos","_requestAppend","_requestPrepend","isLayout","viewSize","isScroll","destroy","src_InfiniteGrid","START","GridLayout_START","CENTER","GridLayout_CENTER","END","GridLayout_END","JUSTIFY","GridLayout_JUSTIFY","layouts_GridLayout","align","itemSize","_columnSize","_columnLength","_style","sizeName","columnSize","size1Name","size2Name","pos1Name","pos2Name","columnLength","viewDist","pointCaculateName","startOutline","endOutline","endIndex","endPos","column","sort","b","item1pos1","item1pos2","item2pos1","item2pos2","startIndex","clone","checkColumn","groups","firstItem","FrameLayout_searchShapeInFrame","frame","j","FrameLayout_disableFrame","layouts_FrameLayout","frameFill","shapes","FrameLayout_getShapes","row","_itemSize","_shapes","_checkItemSize","_getItemSize","isItemObject","itemSize2","itemSize1","shapesSize","shapesLength","dist","minPos","maxPos","shape","shapePos1","shapePos2","shapeSize1","shapeSize2","targetOutline","prevOutlineEnd","prevOutlineDist","SquareLayout_getColumn","dataset","layouts_SquareLayout","SquareLayout_makeShapeOutline","sign","columnWidth","columnCount","lastItem","shape1","shape2","PackingLayout_getCost","originLength","layouts_PackingLayout","aspectRatio","sizeWeight","ratioWeight","getRatio","setOriginWidth","getWidth","setOriginHeight","getHeight","setWidth","setHeight","bestFitArea","minCost","layoutVertical","itemFitSize","containerFitSize","containerSizeCost","getOriginSize","getSize","containerRatioCost","getOriginRatio","itemWidth","itemHeight","containerWidth","containerHeight","getOriginHeight","getOriginWidth","itemRatio","containerSize","containerRatio","setTop","getTop","setLeft","getLeft","PackingLayout_fitArea","containerSize1","prevOutline","utils_toZeroArray","BoxModel_default","startPos","model","_findBestFitArea","pushItem","scaleTo","boxItem","layouts_JustifiedLayout","minSize","maxSize","path","dijkstra_default","_start","results","_getCost","pow","_setStyle","_getSize","isFinite","startPoint","endPoint","path1","path2","pathItems","pathItemsLength","prevItemRect","itemsLength","infinitegrid_src","src_VueInfiniteGrid","scriptExports","render","staticRenderFns","functionalTemplate","injectStyles","scopeId","moduleIdentifier","shadowMode","hook","_compiled","functional","_scopeId","context","$vnode","ssrContext","__VUE_SSR_CONTEXT__","_registeredComponents","_ssrRegister","$root","$options","shadowRoot","_injectStyles","originalRender","h","existing","beforeCreate","normalizeComponent","Number","Boolean","tag","id","_h","$createElement","_self","_c","staticClass","class","customCssClass","attrs","gridId","_t","__webpack_exports__"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"vue-infinite-grid\"] = factory();\n\telse\n\t\troot[\"vue-infinite-grid\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","class BoxModel {\n\tconstructor(option) {\n\t\tthis._originWidth = option.originWidth || 0;\n\t\tthis._originHeight = option.originHeight || 0;\n\t\tthis._width = option.width || 0;\n\t\tthis._height = option.height || 0;\n\t\tthis._left = option.left || 0;\n\t\tthis._top = option.top || 0;\n\t\tthis._item = option.item;\n\t\tthis._innerItem = option.innerItem || [];\n\t}\n\n\tgetOriginWidth() {\n\t\treturn this._originWidth;\n\t}\n\n\tsetOriginWidth(width) {\n\t\tthis._originWidth = width;\n\t}\n\n\tgetOriginHeight() {\n\t\treturn this._originHeight;\n\t}\n\n\tsetOriginHeight(height) {\n\t\tthis._originHeight = height;\n\t}\n\n\tgetWidth() {\n\t\treturn this._width;\n\t}\n\n\tsetWidth(width) {\n\t\tthis._width = width;\n\t}\n\n\tgetHeight() {\n\t\treturn this._height;\n\t}\n\n\tsetHeight(height) {\n\t\tthis._height = height;\n\t}\n\n\tgetLeft() {\n\t\treturn this._left;\n\t}\n\n\tsetLeft(left) {\n\t\tthis._left = left;\n\t}\n\n\tgetTop() {\n\t\treturn this._top;\n\t}\n\n\tsetTop(top) {\n\t\tthis._top = top;\n\t}\n\n\tinnerItem() {\n\t\treturn this._innerItem;\n\t}\n\n\tscaleTo(width, height) {\n\t\tconst scaleX = (this._width === 0) ? 0 : width / this._width;\n\t\tconst scaleY = (this._height === 0) ? 0 : height / this._height;\n\n\t\tthis._innerItem.forEach(v => {\n\t\t\tif (scaleX !== 0) {\n\t\t\t\tv._left *= scaleX;\n\t\t\t\tv._width *= scaleX;\n\t\t\t}\n\t\t\tif (scaleY !== 0) {\n\t\t\t\tv._top *= scaleY;\n\t\t\t\tv._height *= scaleY;\n\t\t\t}\n\t\t});\n\n\t\tthis._width = width;\n\t\tthis._height = height;\n\t}\n\n\tpushItem(item) {\n\t\tthis._innerItem.push(item);\n\t}\n\n\tgetOriginSize() {\n\t\treturn this._originWidth * this._originHeight;\n\t}\n\n\tgetSize() {\n\t\treturn this._width * this._height;\n\t}\n\n\tgetOriginRatio() {\n\t\treturn (this._originHeight === 0) ? 0 : this._originWidth / this._originHeight;\n\t}\n\n\tgetRatio() {\n\t\treturn (this._height === 0) ? 0 : this._width / this._height;\n\t}\n\n\tisSmallerThen(box) {\n\t\treturn (this._width <= box._width && this._height <= box._height);\n\t}\n\n\tisEqual(box) {\n\t\treturn (this._left === box._left &&\n\t\tthis._top === box._top &&\n\t\tthis._width === box._width &&\n\t\tthis._height === box._height);\n\t}\n}\n\nmodule.exports = BoxModel;\n","/* eslint-disable */\n/******************************************************************************\n * Created 2008-08-19.\n *\n * Dijkstra path-finding functions. Adapted from the Dijkstar Python project.\n *\n * Copyright (C) 2008\n *   Wyatt Baldwin <self@wyattbaldwin.com>\n *   All rights reserved\n *\n * Licensed under the MIT license.\n *\n *   http://www.opensource.org/licenses/mit-license.php\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *****************************************************************************/\n (function(){\n    var dijkstra = {\n      single_source_shortest_paths: function(graph, s, d) {\n        // Predecessor map for each node that has been encountered.\n        // node ID => predecessor node ID\n        var predecessors = {};\n\n        // Costs of shortest paths from s to all nodes encountered.\n        // node ID => cost\n        var costs = {};\n        costs[s] = 0;\n\n        // Costs of shortest paths from s to all nodes encountered; differs from\n        // `costs` in that it provides easy access to the node that currently has\n        // the known shortest path from s.\n        // XXX: Do we actually need both `costs` and `open`?\n        var open = new BinaryHeap(function (x) { return x.cost; });\n        open.push({value: s, cost: 0});\n\n        var closest,\n            u,\n            cost_of_s_to_u,\n            adjacent_nodes,\n            cost_of_e,\n            cost_of_s_to_u_plus_cost_of_e,\n            cost_of_s_to_v,\n            first_visit;\n        while (open.size()) {\n          // In the nodes remaining in graph that have a known cost from s,\n          // find the node, u, that currently has the shortest path from s.\n          closest = open.pop();\n          u = closest.value;\n          cost_of_s_to_u = closest.cost;\n\n          // Get nodes adjacent to u...\n          adjacent_nodes = graph(u) || {};\n\n          // ...and explore the edges that connect u to those nodes, updating\n          // the cost of the shortest paths to any or all of those nodes as\n          // necessary. v is the node across the current edge from u.\n          for (var v in adjacent_nodes) {\n            // Get the cost of the edge running from u to v.\n            cost_of_e = adjacent_nodes[v];\n\n            // Cost of s to u plus the cost of u to v across e--this is *a*\n            // cost from s to v that may or may not be less than the current\n            // known cost to v.\n            cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;\n\n            // If we haven't visited v yet OR if the current known cost from s to\n            // v is greater than the new cost we just found (cost of s to u plus\n            // cost of u to v across e), update v's cost in the cost list and\n            // update v's predecessor in the predecessor list (it's now u).\n            cost_of_s_to_v = costs[v];\n            first_visit = (typeof costs[v] === 'undefined');\n            if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {\n              costs[v] = cost_of_s_to_u_plus_cost_of_e;\n              open.push({value: v, cost: cost_of_s_to_u_plus_cost_of_e});\n              predecessors[v] = u;\n            }\n          }\n        }\n\n        if (typeof costs[d] === 'undefined') {\n          var msg = ['Could not find a path from ', s, ' to ', d, '.'].join('');\n          throw new Error(msg);\n        }\n\n        return predecessors;\n      },\n\n      extract_shortest_path_from_predecessor_list: function(predecessors, d) {\n        var nodes = [];\n        var u = d;\n        var predecessor;\n        while (u) {\n          nodes.push(u);\n          predecessor = predecessors[u];\n          u = predecessors[u];\n        }\n        nodes.reverse();\n        return nodes;\n      },\n\n      find_path: function(graph, s, d) {\n        var predecessors = dijkstra.single_source_shortest_paths(graph, s, d);\n        return dijkstra.extract_shortest_path_from_predecessor_list(\n          predecessors, d);\n      }\n\n    };\n\n    function BinaryHeap(scoreFunction){\n      this.content = [];\n      this.scoreFunction = scoreFunction;\n    }\n\n    BinaryHeap.prototype = {\n      push: function(element) {\n        // Add the new element to the end of the array.\n        this.content.push(element);\n        // Allow it to bubble up.\n        this.bubbleUp(this.content.length - 1);\n      },\n\n      pop: function() {\n        // Store the first element so we can return it later.\n        var result = this.content[0];\n        // Get the element at the end of the array.\n        var end = this.content.pop();\n        // If there are any elements left, put the end element at the\n        // start, and let it sink down.\n        if (this.content.length > 0) {\n          this.content[0] = end;\n          this.sinkDown(0);\n        }\n        return result;\n      },\n\n      remove: function(node) {\n        var len = this.content.length;\n        // To remove a value, we must search through the array to find\n        // it.\n        for (var i = 0; i < len; i++) {\n          if (this.content[i] === node) {\n            // When it is found, the process seen in 'pop' is repeated\n            // to fill up the hole.\n            var end = this.content.pop();\n            if (i !== len - 1) {\n              this.content[i] = end;\n              if (this.scoreFunction(end) < this.scoreFunction(node)){\n                this.bubbleUp(i);\n              }else{\n                this.sinkDown(i);\n              }\n            }\n            return;\n          }\n        }\n        throw new Error('Node not found.');\n      },\n\n      size: function() {\n        return this.content.length;\n      },\n\n      bubbleUp: function(n) {\n        // Fetch the element that has to be moved.\n        var element = this.content[n];\n        // When at 0, an element can not go up any further.\n        while (n > 0) {\n          // Compute the parent element's index, and fetch it.\n          var parentN = Math.floor((n + 1) / 2) - 1,\n              parent = this.content[parentN];\n          // Swap the elements if the parent is greater.\n          if (this.scoreFunction(element) < this.scoreFunction(parent)) {\n            this.content[parentN] = element;\n            this.content[n] = parent;\n            // Update 'n' to continue at the new position.\n            n = parentN;\n          }\n          // Found a parent that is less, no need to move it further.\n          else {\n            break;\n          }\n        }\n      },\n\n      sinkDown: function(n) {\n        // Look up the target element and its score.\n        var length = this.content.length,\n            element = this.content[n],\n            elemScore = this.scoreFunction(element);\n\n        while(true) {\n          // Compute the indices of the child elements.\n          var child2N = (n + 1) * 2, child1N = child2N - 1;\n          // This is used to store the new position of the element,\n          // if any.\n          var swap = null;\n          // If the first child exists (is inside the array)...\n          if (child1N < length) {\n            // Look it up and compute its score.\n            var child1 = this.content[child1N],\n                child1Score = this.scoreFunction(child1);\n            // If the score is less than our element's, we need to swap.\n            if (child1Score < elemScore){\n              swap = child1N;\n            }\n          }\n          // Do the same checks for the other child.\n          if (child2N < length) {\n            var child2 = this.content[child2N],\n                child2Score = this.scoreFunction(child2);\n            if (child2Score < (swap == null ? elemScore : child1Score)){\n              swap = child2N;\n            }\n          }\n\n          // If the element needs to be moved, swap it, and continue.\n          if (swap !== null) {\n            this.content[n] = this.content[swap];\n            this.content[swap] = element;\n            n = swap;\n          }\n          // Otherwise, we are done.\n          else {\n            break;\n          }\n        }\n      }\n    };\n\n    /**\n     * Browserify    \n     */\n    if(typeof module !== 'undefined' && module.exports) {\n        module.exports = dijkstra;\n    }else{\n        window.dijkstra = dijkstra;\n    }\n})();\n","/*!\n * Copyright (c) 2017 NAVER Corp.\r\n * @egjs/component project is licensed under the MIT license\r\n * \r\n * @egjs/component JavaScript library\r\n * http://naver.github.io/egjs/component\r\n * \r\n * @version 2.1.0\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Component\"] = factory();\n\telse\n\t\troot[\"eg\"] = root[\"eg\"] || {}, root[\"eg\"][\"Component\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _Component = __webpack_require__(1);\n\nvar _Component2 = _interopRequireDefault(_Component);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n_Component2[\"default\"].VERSION = \"2.1.0\";\nmodule.exports = _Component2[\"default\"];\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nexports.__esModule = true;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\n/**\n * A class used to manage events and options in a component\n * @ko        \n * @alias eg.Component\n */\nvar Component = function () {\n\t/**\n  * @support {\"ie\": \"7+\", \"ch\" : \"latest\", \"ff\" : \"latest\",  \"sf\" : \"latest\", \"edge\" : \"latest\", \"ios\" : \"7+\", \"an\" : \"2.1+ (except 3.x)\"}\n  */\n\tfunction Component() {\n\t\t_classCallCheck(this, Component);\n\n\t\tthis._eventHandler = {};\n\t\tthis.options = {};\n\t}\n\t/**\n  * Triggers a custom event.\n  * @ko   \n  * @param {String} eventName The name of the custom event to be triggered <ko>   </ko>\n  * @param {Object} customEvent Event data to be sent when triggering a custom event <ko>     </ko>\n  * @return {Boolean} Indicates whether the event has occurred. If the stop() method is called by a custom event handler, it will return false and prevent the event from occurring. <a href=\"https://github.com/naver/egjs-component/wiki/How-to-make-Component-event-design%3F\">Ref</a> <ko>  .    stop()   'false'    . <a href=\"https://github.com/naver/egjs-component/wiki/How-to-make-Component-event-design%3F\"></a></ko>\n  * @example\n class Some extends eg.Component {\n  some(){\n  \tif(this.trigger(\"beforeHi\")){ // When event call to stop return false.\n \tthis.trigger(\"hi\");// fire hi event.\n  \t}\n  }\n }\n const some = new Some();\n some.on(\"beforeHi\", (e) => {\n if(condition){\n \te.stop(); // When event call to stop, `hi` event not call.\n }\n });\n some.on(\"hi\", (e) => {\n // `currentTarget` is component instance.\n console.log(some === e.currentTarget); // true\n });\n // If you want to more know event design. You can see article.\n // https://github.com/naver/egjs-component/wiki/How-to-make-Component-event-design%3F\n  */\n\n\n\tComponent.prototype.trigger = function trigger(eventName) {\n\t\tvar customEvent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\t\tvar handlerList = this._eventHandler[eventName] || [];\n\t\tvar hasHandlerList = handlerList.length > 0;\n\n\t\tif (!hasHandlerList) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// If detach method call in handler in first time then handeler list calls.\n\t\thandlerList = handlerList.concat();\n\n\t\tcustomEvent.eventType = eventName;\n\n\t\tvar isCanceled = false;\n\t\tvar arg = [customEvent];\n\t\tvar i = 0;\n\n\t\tcustomEvent.stop = function () {\n\t\t\tisCanceled = true;\n\t\t};\n\t\tcustomEvent.currentTarget = this;\n\n\t\tfor (var _len = arguments.length, restParam = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n\t\t\trestParam[_key - 2] = arguments[_key];\n\t\t}\n\n\t\tif (restParam.length >= 1) {\n\t\t\targ = arg.concat(restParam);\n\t\t}\n\n\t\tfor (i = 0; handlerList[i]; i++) {\n\t\t\thandlerList[i].apply(this, arg);\n\t\t}\n\n\t\treturn !isCanceled;\n\t};\n\t/**\n  * Executed event just one time.\n  * @ko   .\n  * @param {eventName} eventName The name of the event to be attached <ko>  </ko>\n  * @param {Function} handlerToAttach The handler function of the event to be attached <ko>   </ko>\n  * @return {eg.Component} An instance of a component itself<ko>  </ko>\n  * @example\n class Some extends eg.Component {\n  hi() {\n    alert(\"hi\");\n  }\n  thing() {\n    this.once(\"hi\", this.hi);\n  }\n }\n var some = new Some();\n some.thing();\n some.trigger(\"hi\");\n // fire alert(\"hi\");\n some.trigger(\"hi\");\n // Nothing happens\n  */\n\n\n\tComponent.prototype.once = function once(eventName, handlerToAttach) {\n\t\tif ((typeof eventName === \"undefined\" ? \"undefined\" : _typeof(eventName)) === \"object\" && typeof handlerToAttach === \"undefined\") {\n\t\t\tvar eventHash = eventName;\n\t\t\tvar i = void 0;\n\n\t\t\tfor (i in eventHash) {\n\t\t\t\tthis.once(i, eventHash[i]);\n\t\t\t}\n\t\t\treturn this;\n\t\t} else if (typeof eventName === \"string\" && typeof handlerToAttach === \"function\") {\n\t\t\tvar self = this;\n\n\t\t\tthis.on(eventName, function listener() {\n\t\t\t\tfor (var _len2 = arguments.length, arg = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n\t\t\t\t\targ[_key2] = arguments[_key2];\n\t\t\t\t}\n\n\t\t\t\thandlerToAttach.apply(self, arg);\n\t\t\t\tself.off(eventName, listener);\n\t\t\t});\n\t\t}\n\n\t\treturn this;\n\t};\n\n\t/**\n  * Checks whether an event has been attached to a component.\n  * @ko    .\n  * @param {String} eventName The name of the event to be attached <ko>    </ko>\n  * @return {Boolean} Indicates whether the event is attached. <ko>  </ko>\n  * @example\n class Some extends eg.Component {\n  some() {\n    this.hasOn(\"hi\");// check hi event.\n  }\n }\n  */\n\n\n\tComponent.prototype.hasOn = function hasOn(eventName) {\n\t\treturn !!this._eventHandler[eventName];\n\t};\n\n\t/**\n  * Attaches an event to a component.\n  * @ko   .\n  * @param {eventName} eventName The name of the event to be attached <ko>  </ko>\n  * @param {Function} handlerToAttach The handler function of the event to be attached <ko>   </ko>\n  * @return {eg.Component} An instance of a component itself<ko>  </ko>\n  * @example\n class Some extends eg.Component {\n  hi() {\n    console.log(\"hi\");\n  }\n  some() {\n    this.on(\"hi\",this.hi); //attach event\n  }\n }\n */\n\n\n\tComponent.prototype.on = function on(eventName, handlerToAttach) {\n\t\tif ((typeof eventName === \"undefined\" ? \"undefined\" : _typeof(eventName)) === \"object\" && typeof handlerToAttach === \"undefined\") {\n\t\t\tvar eventHash = eventName;\n\t\t\tvar name = void 0;\n\n\t\t\tfor (name in eventHash) {\n\t\t\t\tthis.on(name, eventHash[name]);\n\t\t\t}\n\t\t\treturn this;\n\t\t} else if (typeof eventName === \"string\" && typeof handlerToAttach === \"function\") {\n\t\t\tvar handlerList = this._eventHandler[eventName];\n\n\t\t\tif (typeof handlerList === \"undefined\") {\n\t\t\t\tthis._eventHandler[eventName] = [];\n\t\t\t\thandlerList = this._eventHandler[eventName];\n\t\t\t}\n\n\t\t\thandlerList.push(handlerToAttach);\n\t\t}\n\n\t\treturn this;\n\t};\n\t/**\n  * Detaches an event from the component.\n  * @ko    \n  * @param {eventName} eventName The name of the event to be detached <ko>  </ko>\n  * @param {Function} handlerToDetach The handler function of the event to be detached <ko>   </ko>\n  * @return {eg.Component} An instance of a component itself <ko>  </ko>\n  * @example\n class Some extends eg.Component {\n  hi() {\n    console.log(\"hi\");\n  }\n  some() {\n    this.off(\"hi\",this.hi); //detach event\n  }\n }\n  */\n\n\n\tComponent.prototype.off = function off(eventName, handlerToDetach) {\n\t\t// All event detach.\n\t\tif (typeof eventName === \"undefined\") {\n\t\t\tthis._eventHandler = {};\n\t\t\treturn this;\n\t\t}\n\n\t\t// All handler of specific event detach.\n\t\tif (typeof handlerToDetach === \"undefined\") {\n\t\t\tif (typeof eventName === \"string\") {\n\t\t\t\tthis._eventHandler[eventName] = undefined;\n\t\t\t\treturn this;\n\t\t\t} else {\n\t\t\t\tvar eventHash = eventName;\n\t\t\t\tvar name = void 0;\n\n\t\t\t\tfor (name in eventHash) {\n\t\t\t\t\tthis.off(name, eventHash[name]);\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\n\t\t// The handler of specific event detach.\n\t\tvar handlerList = this._eventHandler[eventName];\n\n\t\tif (handlerList) {\n\t\t\tvar k = void 0;\n\t\t\tvar handlerFunction = void 0;\n\n\t\t\tfor (k = 0; (handlerFunction = handlerList[k]) !== undefined; k++) {\n\t\t\t\tif (handlerFunction === handlerToDetach) {\n\t\t\t\t\thandlerList = handlerList.splice(k, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t};\n\n\treturn Component;\n}();\n\nexports[\"default\"] = Component;\nmodule.exports = exports[\"default\"];\n\n/***/ })\n/******/ ]);\n});\n//# sourceMappingURL=component.js.map","/* eslint-disable no-new-func, no-nested-ternary */\nconst win = window;\n/* eslint-enable no-new-func, no-nested-ternary */\n\nexport {win as window};\nexport const document = win.document;\n","import {window} from \"./browser\";\n\nconst ua = window.navigator.userAgent;\n\nexport const SUPPORT_COMPUTEDSTYLE = !!(\"getComputedStyle\" in window);\nexport const SUPPORT_ADDEVENTLISTENER = !!(\"addEventListener\" in document);\nexport const SUPPORT_PASSIVE = (() => {\n\tlet supportsPassiveOption = false;\n\n\ttry {\n\t\tif (SUPPORT_ADDEVENTLISTENER && Object.defineProperty) {\n\t\t\tdocument.addEventListener(\"test\", null, Object.defineProperty({},\n\t\t\t\t\"passive\", {\n\t\t\t\t\tget() {\n\t\t\t\t\t\tsupportsPassiveOption = true;\n\t\t\t\t\t},\n\t\t\t\t}));\n\t\t}\n\t} catch (e) {}\n\treturn supportsPassiveOption;\n})();\n\nexport const IS_IE = /MSIE|Trident|Windows Phone|Edge/.test(ua);\nexport const IS_IOS = /iPhone|iPad/.test(ua);\nexport const IS_ANDROID2 = /Android 2\\./.test(ua);\nexport const RETRY = 3;\nexport const CONTAINER_CLASSNAME = \"_eg-infinitegrid-container_\";\nexport const IGNORE_CLASSNAME = \"_eg-infinitegrid-ignore_\";\n\nexport const APPEND = true;\nexport const PREPEND = false;\nexport const VERTICAL = \"vertical\";\nexport const HORIZONTAL = \"horizontal\";\nexport const CACHE = true;\nexport const NO_CACHE = false;\nexport const TRUSTED = true;\nexport const NO_TRUSTED = false;\nexport const MULTI = true;\nexport const SINGLE = false;\nexport const DUMMY_POSITION = -100000;\nexport const GROUPKEY_ATT = \"data-groupkey\";\n\nexport const DEFAULT_OPTIONS = {\n\thorizontal: false,\n\tmargin: 0,\n};\n\nexport const agent = ua.toLowerCase();\nexport const isMobile = /mobi|ios|android/.test(agent);\n\nexport const ALIGN = {\n\tSTART: \"start\",\n\tCENTER: \"center\",\n\tEND: \"end\",\n\tJUSTIFY: \"justify\",\n};\n\nexport const IDLE = 0;\nexport const LOADING_APPEND = 1;\nexport const LOADING_PREPEND = 2;\nexport const PROCESSING = 4;\n\n\nconst webkit = /applewebkit\\/([\\d|.]*)/g.exec(agent);\n\nexport const WEBKIT_VERSION = (webkit && parseInt(webkit[1], 10)) || 0;\nexport const DEFENSE_BROWSER = (WEBKIT_VERSION && WEBKIT_VERSION < 537);\n","import {window, document} from \"./browser\";\nimport {\n\tSUPPORT_COMPUTEDSTYLE,\n\tSUPPORT_ADDEVENTLISTENER,\n\tSUPPORT_PASSIVE,\n\tVERTICAL,\n\tHORIZONTAL,\n\tDEFAULT_OPTIONS,\n} from \"./consts\";\n\nexport function toArray(nodes) {\n\t// SCRIPT5014 in IE8\n\tconst array = [];\n\n\tif (nodes) {\n\t\tfor (let i = 0, len = nodes.length; i < len; i++) {\n\t\t\tarray.push(nodes[i]);\n\t\t}\n\t}\n\treturn array;\n}\nexport function matchHTML(html) {\n\treturn html.match(/^<([A-z]+)\\s*([^>]*)>/);\n}\n/**\n * Select or create element\n * @param {String|HTMLElement|jQuery} param\n *  when string given is as HTML tag, then create element\n *  otherwise it returns selected elements\n * @param {Boolean} multi\n * @returns {HTMLElement}\n */\nexport function $(param, multi = false) {\n\tlet el;\n\n\tif (typeof param === \"string\") { // String (HTML, Selector)\n\t\t// check if string is HTML tag format\n\t\tconst match = matchHTML(param);\n\n\t\t// creating element\n\t\tif (match) { // HTML\n\t\t\tconst dummy = document.createElement(\"div\");\n\n\t\t\tdummy.innerHTML = param;\n\t\t\tel = dummy.childNodes;\n\t\t} else { // Selector\n\t\t\tel = document.querySelectorAll(param);\n\t\t}\n\t\tif (multi) {\n\t\t\tel = toArray(el);\n\t\t} else {\n\t\t\tel = (el && el.length > 0 && el[0]) || undefined;\n\t\t}\n\t} else if (param === window) { // window\n\t\tel = param;\n\t} else if (param.nodeName &&\n\t\t(param.nodeType === 1 || param.nodeType === 9)) { // HTMLElement, Document\n\t\tel = param;\n\t} else if ((\"jQuery\" in window && param instanceof window.jQuery) ||\n\t\tparam.constructor.prototype.jquery) { // jQuery\n\t\tel = multi ? param.toArray() : param.get(0);\n\t} else if (Array.isArray(param)) {\n\t\tel = param.map(v => $(v));\n\t\tif (!multi) {\n\t\t\tel = el.length >= 1 ? el[0] : undefined;\n\t\t}\n\t}\n\treturn el;\n}\nexport function addEvent(element, type, handler, eventListenerOptions) {\n\tif (SUPPORT_ADDEVENTLISTENER) {\n\t\tlet options = eventListenerOptions || false;\n\n\t\tif (typeof eventListenerOptions === \"object\") {\n\t\t\toptions = SUPPORT_PASSIVE ? eventListenerOptions : false;\n\t\t}\n\t\telement.addEventListener(type, handler, options);\n\t} else if (element.attachEvent) {\n\t\telement.attachEvent(`on${type}`, handler);\n\t} else {\n\t\telement[`on${type}`] = handler;\n\t}\n}\nexport function removeEvent(element, type, handler) {\n\tif (element.removeEventListener) {\n\t\telement.removeEventListener(type, handler, false);\n\t} else if (element.detachEvent) {\n\t\telement.detachEvent(`on${type}`, handler);\n\t} else {\n\t\telement[`on${type}`] = null;\n\t}\n}\nexport function scroll(el, isVertical) {\n\tconst prop = `scroll${isVertical ? \"Top\" : \"Left\"}`;\n\n\tif (el === window) {\n\t\treturn window[isVertical ? \"pageYOffset\" : \"pageXOffset\"] || document.body[prop] || document.documentElement[prop];\n\t} else {\n\t\treturn el[prop];\n\t}\n}\nexport function scrollTo(el, x, y) {\n\tif (el === window) {\n\t\tel.scroll(x, y);\n\t} else {\n\t\tel.scrollLeft = x;\n\t\tel.scrollTop = y;\n\t}\n}\nexport function scrollBy(el, x, y) {\n\tif (el === window) {\n\t\tel.scrollBy(x, y);\n\t} else {\n\t\tel.scrollLeft += x;\n\t\tel.scrollTop += y;\n\t}\n}\nexport function getStyles(el) {\n\treturn SUPPORT_COMPUTEDSTYLE ?\n\t\twindow.getComputedStyle(el) : el.currentStyle;\n}\nfunction _getSize(el, name) {\n\tif (el === window) { // WINDOW\n\t\treturn el.document.documentElement[`client${name}`];\n\t} else if (el.nodeType === 9) { // DOCUMENT_NODE\n\t\tconst doc = el.documentElement;\n\n\t\treturn Math.max(\n\t\t\tel.body[`scroll${name}`], doc[`scroll${name}`],\n\t\t\tel.body[`offset${name}`], doc[`offset${name}`],\n\t\t\tdoc[`client${name}`]\n\t\t);\n\t} else { // NODE\n\t\tconst style = getStyles(el);\n\t\tconst value = style[name.toLowerCase()];\n\n\t\treturn parseFloat(/auto|%/.test(value) ? el[`offset${name}`] : style[name.toLowerCase()]);\n\t}\n}\nexport function innerWidth(el) {\n\treturn _getSize(el, \"Width\");\n}\nexport function innerHeight(el) {\n\treturn _getSize(el, \"Height\");\n}\nexport const STYLE = {\n\tvertical: {\n\t\tpos1: \"top\",\n\t\tendPos1: \"bottom\",\n\t\tsize1: \"height\",\n\t\tpos2: \"left\",\n\t\tendPos2: \"right\",\n\t\tsize2: \"width\",\n\t},\n\thorizontal: {\n\t\tpos1: \"left\",\n\t\tendPos1: \"right\",\n\t\tsize1: \"width\",\n\t\tpos2: \"top\",\n\t\tendPos2: \"bottom\",\n\t\tsize2: \"height\",\n\t},\n};\n\nexport function getStyleNames(isHorizontal) {\n\treturn STYLE[isHorizontal ? HORIZONTAL : VERTICAL];\n}\n\nexport function assignOptions(defaultOptions, options) {\n\treturn Object.assign({},\n\t\tDEFAULT_OPTIONS,\n\t\tdefaultOptions,\n\t\toptions);\n}\n\nexport function toZeroArray(outline) {\n\tif (!outline || !outline.length) {\n\t\treturn [0];\n\t}\n\treturn outline;\n}\n\nexport function isWindow(el) {\n\treturn el === window;\n}\n\nexport function fill(arr, value) {\n\tconst length = arr.length;\n\n\tfor (let i = length - 1; i >= 0; --i) {\n\t\tarr[i] = value;\n\t}\n\n\treturn arr;\n}\n","import {\n\tAPPEND,\n\tPREPEND,\n\tDUMMY_POSITION,\n\tMULTI,\n\tGROUPKEY_ATT,\n\tCONTAINER_CLASSNAME,\n\tDEFENSE_BROWSER,\n} from \"./consts\";\nimport {\n\t$,\n\tscrollBy,\n\tinnerHeight,\n\tinnerWidth,\n\tgetStyles,\n} from \"./utils\";\n\n\nfunction _defense(element) {\n\tconst container = document.createElement(\"div\");\n\n\tcontainer.className = CONTAINER_CLASSNAME;\n\tcontainer.style.position = \"relative\";\n\tcontainer.style.height = \"100%\";\n\n\tconst children = element.children;\n\tconst length = children.length;\t// for IE8\n\n\tfor (let i = 0; i < length; i++) {\n\t\tcontainer.appendChild(children[0]);\n\t}\n\n\telement.appendChild(container);\n\treturn container;\n}\nexport default class DOMRenderer {\n\tstatic renderItem(item, styles) {\n\t\tif (item.el) {\n\t\t\tconst elStyle = item.el.style;\n\n\t\t\t// for debugging\n\t\t\titem.el.setAttribute(GROUPKEY_ATT, item.groupKey);\n\t\t\telStyle.position = \"absolute\";\n\t\t\t[\"left\", \"top\", \"width\", \"height\"].forEach(p => {\n\t\t\t\t(p in styles) && (elStyle[p] = `${styles[p]}px`);\n\t\t\t});\n\t\t}\n\t}\n\tstatic renderItems(items) {\n\t\titems.forEach(item => {\n\t\t\tDOMRenderer.renderItem(item, item.rect);\n\t\t});\n\t}\n\tstatic removeItems(items) {\n\t\titems.forEach(item => {\n\t\t\tif (item.el) {\n\t\t\t\tDOMRenderer.removeElement(item.el);\n\t\t\t\titem.el = null;\n\t\t\t}\n\t\t});\n\t}\n\tstatic removeElement(element) {\n\t\telement.parentNode.removeChild(element);\n\t}\n\tstatic createElements(items) {\n\t\tconst elements = $(items.reduce((acc, v, i) => {\n\t\t\tacc.push(v.content.replace(/^[\\s\\uFEFF]+|[\\s\\uFEFF]+$/g, \"\"));\n\t\t\treturn acc;\n\t\t}, []).join(\"\"), MULTI);\n\n\t\treturn items.map((item, index) => {\n\t\t\titem.el = elements[index];\n\t\t\treturn item;\n\t\t});\n\t}\n\tconstructor(element, options) {\n\t\tObject.assign(this.options = {\n\t\t\tisOverflowScroll: false,\n\t\t\tisEqualSize: false,\n\t\t\tisVertical: true,\n\t\t}, options);\n\t\tthis._size = {\n\t\t\tcontainerOffset: 0,\n\t\t\tcontainer: -1,\n\t\t\tview: -1,\n\t\t\titem: null,\n\t\t};\n\t\tthis._init(element);\n\t\tthis.resize();\n\t}\n\tgetStatus() {\n\t\treturn {\n\t\t\tcssText: this.container.style.cssText,\n\t\t\toptions: Object.assign({}, this.options),\n\t\t\t_size: Object.assign({}, this._size),\n\t\t};\n\t}\n\tsetStatus(status, items) {\n\t\tthis.container.style.cssText = status.cssText;\n\t\tObject.assign(this.options, status.options);\n\t\tObject.assign(this._size, status._size);\n\n\t\tDOMRenderer.renderItems(items);\n\t\tthis._insert(items, APPEND);\n\t}\n\tupdateSize(items) {\n\t\treturn items.map(item => {\n\t\t\tif (item.el) {\n\t\t\t\tif (this.options.isEqualSize) {\n\t\t\t\t\tthis._size.item = this._size.item || {\n\t\t\t\t\t\twidth: innerWidth(item.el),\n\t\t\t\t\t\theight: innerHeight(item.el),\n\t\t\t\t\t};\n\t\t\t\t\titem.size = Object.assign({}, this._size.item);\n\t\t\t\t} else {\n\t\t\t\t\titem.size = {\n\t\t\t\t\t\twidth: innerWidth(item.el),\n\t\t\t\t\t\theight: innerHeight(item.el),\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif (!item.orgSize) {\n\t\t\t\t\titem.orgSize = Object.assign({}, item.size);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn item;\n\t\t});\n\t}\n\t_init(el) {\n\t\tconst element = $(el);\n\t\tconst style = getStyles(element);\n\n\t\tthis._orgStyle = {};\n\n\t\tif (style.position === \"static\") {\n\t\t\tthis._orgStyle.position = element.style.position;\n\t\t\telement.style.position = \"relative\";\n\t\t}\n\t\tif (this.options.isOverflowScroll) {\n\t\t\tconst target = this.options.isVertical ? [\"Y\", \"X\"] : [\"X\", \"Y\"];\n\n\t\t\tthis._orgStyle.overflowX = element.style.overflowX;\n\t\t\tthis._orgStyle.overflowY = element.style.overflowY;\n\t\t\telement.style[`overflow${target[0]}`] = \"scroll\";\n\t\t\telement.style[`overflow${target[1]}`] = \"hidden\";\n\t\t\tthis.view = element;\n\t\t\t// defense code for android < 4.4 or webkit < 537\n\t\t\tthis.container = !this.options.isVertical && DEFENSE_BROWSER ? _defense(element) : element;\n\t\t} else {\n\t\t\tthis.view = window;\n\t\t\tthis.container = element;\n\t\t}\n\t}\n\tappend(items) {\n\t\tthis._insert(items, APPEND, {\n\t\t\ttop: DUMMY_POSITION,\n\t\t\tleft: DUMMY_POSITION,\n\t\t});\n\t}\n\tprepend(items) {\n\t\tthis._insert(items, PREPEND, {\n\t\t\ttop: DUMMY_POSITION,\n\t\t\tleft: DUMMY_POSITION,\n\t\t});\n\t}\n\tclear() {\n\t\tthis.container.innerHTML = \"\";\n\t\tif (!this.options.isOverflowScroll) {\n\t\t\tthis.container.style[this.options.isVertical ? \"height\" : \"width\"] = \"\";\n\t\t}\n\t\tthis._size = {\n\t\t\titem: null,\n\t\t\tcontainerOffset: 0,\n\t\t\tviewport: -1,\n\t\t\tcontainer: -1,\n\t\t\tview: -1,\n\t\t};\n\t}\n\tcreateAndInsert(items, isAppend) {\n\t\tconst itemsWithElement = DOMRenderer.createElements(items);\n\n\t\tDOMRenderer.renderItems(itemsWithElement);\n\t\tthis._insert(itemsWithElement, isAppend);\n\t}\n\t_insert(items, isAppend, styles) {\n\t\tconst df = document.createDocumentFragment();\n\n\t\titems.forEach(item => {\n\t\t\tstyles && DOMRenderer.renderItem(item, styles);\n\t\t\tisAppend ? df.appendChild(item.el) : df.insertBefore(item.el, df.firstChild);\n\t\t});\n\t\tisAppend ?\n\t\t\tthis.container.appendChild(df) :\n\t\t\tthis.container.insertBefore(df, this.container.firstChild);\n\t}\n\t_calcSize() {\n\t\treturn this.options.isVertical ?\n\t\t\tinnerWidth(this.container) : innerHeight(this.container);\n\t}\n\tgetViewSize() {\n\t\treturn this._size.view;\n\t}\n\tscrollBy(point) {\n\t\tconst pos = this.options.isVertical ? [0, point] : [point, 0];\n\n\t\tscrollBy(this.view, ...pos);\n\t}\n\tgetContainerOffset() {\n\t\treturn this._size.containerOffset;\n\t}\n\tgetViewportSize() {\n\t\tthis.resize();\n\t\treturn this._size.viewport;\n\t}\n\tsetContainerSize(size) {\n\t\tif (!this.options.isOverflowScroll || (!this.options.isVertical && DEFENSE_BROWSER)) {\n\t\t\tthis.container.style[this.options.isVertical ? \"height\" : \"width\"] = `${size}px`;\n\t\t}\n\t}\n\tresize() {\n\t\tconst isVertical = this.options.isVertical;\n\n\t\tif (this.isNeededResize()) {\n\t\t\tthis._size = {\n\t\t\t\tcontainerOffset: this.options.isOverflowScroll ? 0 : this.container[`offset${isVertical ? \"Top\" : \"Left\"}`],\n\t\t\t\tviewport: this._calcSize(),\n\t\t\t\tview: isVertical ? innerHeight(this.view) : innerWidth(this.view),\n\t\t\t\titem: null,\n\t\t\t};\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis._size.view = isVertical ? innerHeight(this.view) : innerWidth(this.view);\n\t\t}\n\t\treturn false;\n\t}\n\tisNeededResize() {\n\t\treturn this._calcSize() !== this._size.viewport;\n\t}\n\tdestroy() {\n\t\tthis._size = {\n\t\t\tcontainerOffset: 0,\n\t\t\tviewport: -1,\n\t\t\tview: -1,\n\t\t\titem: null,\n\t\t};\n\t\tthis.container.style[this.options.isVertical ? \"height\" : \"width\"] = \"\";\n\t\tfor (const p in this._orgStyle) {\n\t\t\tthis[this.options.isOverflowScroll ? \"view\" : \"container\"].style[p] = this._orgStyle[p];\n\t\t}\n\t}\n}\n\n","import {MULTI, GROUPKEY_ATT, IGNORE_CLASSNAME} from \"./consts\";\nimport DOMRenderer from \"./DOMRenderer\";\nimport {$, toArray} from \"./utils\";\n\nexport default class ItemManager {\n\tstatic from(elements, selector, {groupKey, isAppend}) {\n\t\tconst filted = ItemManager.selectItems($(elements, MULTI), selector);\n\n\t\t// Item Structure\n\t\treturn toArray(filted).map(el => ({\n\t\t\tel,\n\t\t\tgroupKey,\n\t\t\tcontent: el.outerHTML,\n\t\t}));\n\t}\n\tstatic selectItems(elements, selector = \"*\") {\n\t\treturn elements.filter(v => {\n\t\t\tconst classNames = v.className.split(\" \");\n\n\t\t\tif (classNames.some(c => c === IGNORE_CLASSNAME)) {\n\t\t\t\treturn false;\n\t\t\t} else if (!selector || selector === \"*\") {\n\t\t\t\treturn v;\n\t\t\t} else {\n\t\t\t\treturn classNames.some(c => c === selector);\n\t\t\t}\n\t\t});\n\t}\n\tstatic pluck(data, property) {\n\t\treturn data.reduce((acc, v) => acc.concat(v[property]), []);\n\t}\n\tconstructor() {\n\t\tthis.clear();\n\t}\n\tgetStatus() {\n\t\treturn {\n\t\t\t_data: this._data.map(data => {\n\t\t\t\tconst items = data.items.map(item => {\n\t\t\t\t\tconst item2 = Object.assign({}, item);\n\n\t\t\t\t\tdelete item2.el;\n\t\t\t\t\treturn item2;\n\t\t\t\t});\n\t\t\t\tconst data2 = Object.assign({}, data);\n\n\t\t\t\tdata2.items = items;\n\t\t\t\treturn data2;\n\t\t\t}),\n\t\t};\n\t}\n\tsetStatus(status, start, end) {\n\t\tconst data = status._data;\n\n\t\tfor (let i = start; i <= end; i++) {\n\t\t\tdata[i].items = DOMRenderer.createElements(data[i].items);\n\t\t}\n\t\tthis.set(data);\n\t}\n\tsize() {\n\t\treturn this._data.length;\n\t}\n\tfit(base, isVertical) {\n\t\tif (!this._data.length) {\n\t\t\treturn;\n\t\t}\n\t\tconst property = isVertical ? \"top\" : \"left\";\n\n\t\tif (base !== 0) {\n\t\t\tthis._data = this._data.map(v => {\n\t\t\t\tv.items = v.items.map(item => {\n\t\t\t\t\titem.rect[property] -= base;\n\t\t\t\t\treturn item;\n\t\t\t\t});\n\t\t\t\tv.outlines.start = v.outlines.start.map(start => start - base);\n\t\t\t\tv.outlines.end = v.outlines.end.map(end => end - base);\n\t\t\t\treturn v;\n\t\t\t});\n\t\t}\n\t}\n\tpluck(property, start, end) {\n\t\tif (typeof start !== \"undefined\") {\n\t\t\tif (typeof end !== \"undefined\") {\n\t\t\t\treturn ItemManager.pluck(this._data.slice(start, end + 1), property);\n\t\t\t} else {\n\t\t\t\treturn ItemManager.pluck(this._data.slice(start, start + 1), property);\n\t\t\t}\n\t\t} else {\n\t\t\treturn ItemManager.pluck(this._data, property);\n\t\t}\n\t}\n\tgetOutline(index, property) {\n\t\tif (this._data.length) {\n\t\t\treturn this._data[index].outlines[property];\n\t\t} else {\n\t\t\treturn [];\n\t\t}\n\t}\n\tgetEdgeIndex(cursor, start, end) {\n\t\tconst prop = cursor === \"start\" ? \"min\" : \"max\";\n\t\tlet index = -1;\n\t\tlet targetValue = cursor === \"start\" ? Infinity : -Infinity;\n\n\t\tfor (let i = start; i <= end; i++) {\n\t\t\tconst value = Math[prop](...this.getOutline(i, cursor));\n\n\t\t\tif ((cursor === \"start\" && targetValue > value) ||\n\t\t\t\t(cursor === \"end\" && targetValue < value)) {\n\t\t\t\ttargetValue = value;\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\tgetEdge(cursor, start, end) {\n\t\tconst dataIdx = this.getEdgeIndex(cursor, start, end);\n\t\tconst items = this.pluck(\"items\", dataIdx);\n\n\t\tif (items.length) {\n\t\t\tconst itemIdx = this.getOutline(dataIdx, `${cursor}Index`);\n\n\t\t\treturn items.length > itemIdx ? items[itemIdx] : null;\n\t\t}\n\t\treturn null;\n\t}\n\tgetEdgeValue(cursor, start, end) {\n\t\tconst outlines = this.pluck(\"outlines\", this.getEdgeIndex(cursor, start, end))\n\t\t\t.reduce((acc, v) => acc.concat(v[cursor]), []);\n\n\t\treturn outlines.length ? Math[cursor === \"start\" ? \"min\" : \"max\"](...outlines) : 0;\n\t}\n\tappend(layouted) {\n\t\tthis._data.push(layouted);\n\t\treturn layouted.items;\n\t}\n\tprepend(layouted) {\n\t\tthis._data.unshift(layouted);\n\t\treturn layouted.items;\n\t}\n\tclear() {\n\t\tthis._data = [];\n\t}\n\tremove(element, start, end) {\n\t\tlet items = null;\n\t\tconst key = element.getAttribute(GROUPKEY_ATT);\n\t\tlet data = this.get(start, end)\n\t\t\t.filter(v => String(v.groupKey) === key);\n\n\t\tif (!data.length) {\n\t\t\treturn items;\n\t\t}\n\t\tdata = data[0];\n\n\t\tconst len = data.items.length;\n\t\tlet idx = -1;\n\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tif (data.items[i].el === element) {\n\t\t\t\tidx = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (~idx) {\n\t\t\t// remove item information\n\t\t\tdata.items.splice(idx, 1);\n\t\t\tthis.set(data, key);\n\t\t\titems = data.items;\n\t\t}\n\t\treturn items;\n\t}\n\tget(start, end) {\n\t\tif (typeof start !== \"undefined\") {\n\t\t\tif (typeof end !== \"undefined\") {\n\t\t\t\treturn this._data.slice(start, end + 1);\n\t\t\t} else {\n\t\t\t\treturn this._data.slice(start, start + 1);\n\t\t\t}\n\t\t} else {\n\t\t\treturn this._data.concat();\n\t\t}\n\t}\n\tset(data, key) {\n\t\tif (typeof key !== \"undefined\" && !Array.isArray(data)) {\n\t\t\tconst len = this._data.length;\n\t\t\tlet idx = -1;\n\n\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\tif (this._data[i].groupKey === key) {\n\t\t\t\t\tidx = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t~idx && (this._data[idx] = data);\n\t\t} else {\n\t\t\tthis._data = data.concat();\n\t\t}\n\t}\n}\n","import {window} from \"./browser\";\nimport {addEvent, removeEvent, innerWidth, innerHeight} from \"./utils\";\n\nconst elements = [];\n/* eslint-disable */\nfunction onResize(e) {\n\tAutoSizer.resizeAll();\n}\n/* eslint-enable */\n\nexport default class AutoSizer {\n\tstatic add(element, prefix = \"data-\") {\n\t\tif (!element.length) {\n\t\t\taddEvent(window, \"resize\", onResize);\n\t\t}\n\t\telement.__PREFIX__ = prefix;\n\t\telements.push(element);\n\t\tAutoSizer.resize(element);\n\t}\n\tstatic remove(element, isFixed = false) {\n\t\tconst fixed = element.getAttribute(`${element.__PREFIX__}fixed`) || \"width\";\n\n\t\tif (!isFixed) {\n\t\t\telement.style[fixed === \"width\" ? \"height\" : \"width\"] = \"\";\n\t\t}\n\t\tconst index = elements.indexOf(element);\n\n\t\tif (!~index) {\n\t\t\treturn;\n\t\t}\n\t\telements.splice(index, 1);\n\t\tif (!elements.length) {\n\t\t\tremoveEvent(window, \"reisze\", onResize);\n\t\t}\n\t}\n\tstatic resize(element, prefix = \"data-\") {\n\t\tconst elementPrefix = typeof element.__PREFIX__ === \"string\" ? element.__PREFIX__ : prefix;\n\t\tconst dataWidth = element.getAttribute(`${elementPrefix}width`);\n\t\tconst dataHeight = element.getAttribute(`${elementPrefix}height`);\n\t\tconst fixed = element.getAttribute(`${elementPrefix}fixed`) || \"width\";\n\n\t\tif (fixed === \"width\") {\n\t\t\tconst size = innerWidth(element) || dataWidth;\n\n\t\t\telement.style.height = `${dataHeight / dataWidth * size}px`;\n\t\t} else if (fixed === \"height\") {\n\t\t\tconst size = innerHeight(element) || dataHeight;\n\n\t\t\telement.style.width = `${dataWidth / dataHeight * size}px`;\n\t\t}\n\t}\n\tstatic resizeAll() {\n\t\telements.forEach(element => AutoSizer.resize(element));\n\t}\n}\n","import {IS_IE} from \"./consts\";\nimport {addEvent, removeEvent, toArray} from \"./utils\";\nimport AutoSizer from \"./AutoSizer\";\n\n\nexport const CHECK_ALL = 1;\nexport const CHECK_ONLY_ERROR = 2;\n\n\nconst errorImages = [];\n\nfunction isDataAttribute(target, prefix) {\n\treturn !!target.getAttribute(`${prefix}width`);\n}\n\nclass ImageLoaded {\n\tstatic waitImageLoaded(needCheck, {prefix, length, type, complete, error, end}) {\n\t\tlet checkCount = 0;\n\t\tlet endCount = length || needCheck.reduce((sum, element) => sum + element.length, 0);\n\n\t\tif (type !== CHECK_ONLY_ERROR) {\n\t\t\tcheckCount = endCount;\n\t\t}\n\t\tconst checkEnd = function() {\n\t\t\tif (--endCount !== 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tend && end();\n\t\t};\n\t\tconst checkImage = function() {\n\t\t\tcheckCount--;\n\t\t\tif (checkCount !== 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcomplete && complete();\n\t\t};\n\t\tconst onError = function(target) {\n\t\t\terror && error({\n\t\t\t\ttarget,\n\t\t\t\titemIndex: target.__ITEM_INDEX__,\n\t\t\t});\n\t\t};\n\t\tconst onCheck = function(e) {\n\t\t\tconst target = e.target || e.srcElement;\n\n\t\t\tremoveEvent(target, \"error\", onCheck);\n\t\t\tremoveEvent(target, \"load\", onCheck);\n\n\t\t\tif (type === CHECK_ALL && isDataAttribute(target, prefix)) {\n\t\t\t\tAutoSizer.remove(target, e.type === \"error\");\n\t\t\t} else {\n\t\t\t\tcheckImage();\n\t\t\t}\n\t\t\tif (e.type === \"error\") {\n\t\t\t\terrorImages.push(target.src);\n\t\t\t\tonError(target);\n\t\t\t}\n\t\t\tdelete target.__ITEM_INDEX__;\n\t\t\tcheckEnd();\n\t\t};\n\n\t\tneedCheck.forEach((images, i) => {\n\t\t\timages.forEach(v => {\n\t\t\t\t// workaround for IE\n\t\t\t\tif (v.complete) {\n\t\t\t\t\tif (errorImages.indexOf(v.src) !== -1) {\n\t\t\t\t\t\tonError(v);\n\t\t\t\t\t}\n\t\t\t\t\tcheckImage();\n\t\t\t\t\tcheckEnd();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tv.__ITEM_INDEX__ = i;\n\t\t\t\tif (type === CHECK_ALL && isDataAttribute(v, prefix)) {\n\t\t\t\t\tAutoSizer.add(v, prefix);\n\t\t\t\t\tcheckImage();\n\t\t\t\t}\n\t\t\t\taddEvent(v, \"load\", onCheck);\n\t\t\t\taddEvent(v, \"error\", onCheck);\n\n\t\t\t\tIS_IE && v.setAttribute(\"src\", v.getAttribute(\"src\"));\n\t\t\t});\n\t\t});\n\t}\n\tstatic checkImageLoaded(el) {\n\t\tif (el.tagName === \"IMG\") {\n\t\t\treturn !el.complete ? [el] : [];\n\t\t} else {\n\t\t\treturn toArray(el.querySelectorAll(\"img\"));\n\t\t}\n\t}\n\tstatic check(elements, {prefix, type = CHECK_ALL, complete, error, end}) {\n\t\tconst images = elements.map(element => this.checkImageLoaded(element));\n\t\tconst length = images.reduce((sum, element) => sum + element.length, 0);\n\n\t\tif (type === CHECK_ONLY_ERROR || length === 0) {\n\t\t\t// convert to async\n\t\t\tsetTimeout(() => {\n\t\t\t\tcomplete && complete();\n\t\t\t\tif (length === 0) {\n\t\t\t\t\tend && end();\n\t\t\t\t}\n\t\t\t}, 0);\n\t\t}\n\t\tif (length > 0) {\n\t\t\tthis.waitImageLoaded(images, {prefix, length, type, complete, error, end});\n\t\t}\n\t}\n}\n\nexport default ImageLoaded;\n","import {\n\tIS_IOS,\n} from \"./consts\";\nimport {\n\taddEvent,\n\tremoveEvent,\n\tscroll,\n\tscrollTo,\n} from \"./utils\";\n\nexport default class Watcher {\n\tconstructor(renderer, callback) {\n\t\tObject.assign(this._callback = {\n\t\t\tlayout: null,\n\t\t\tcheck: null,\n\t\t}, callback);\n\t\tthis._timer = {\n\t\t\tresize: null,\n\t\t\t// doubleCheck: null,\n\t\t\t// doubleCheckCount: RETRY,\n\t\t};\n\t\tthis.reset();\n\t\tthis._renderer = renderer;\n\t\tthis._onCheck = this._onCheck.bind(this);\n\t\tthis._onResize = this._onResize.bind(this);\n\t\tthis.attachEvent();\n\t\tthis.setScrollPos();\n\t}\n\tgetStatus() {\n\t\treturn {\n\t\t\t_prevPos: this._prevPos,\n\t\t\tscrollPos: this.getOrgScrollPos(),\n\t\t};\n\t}\n\tsetStatus(status, applyScrollPos = true) {\n\t\tthis._prevPos = status._prevPos;\n\t\tapplyScrollPos && this.scrollTo(status.scrollPos);\n\t}\n\tscrollTo(pos) {\n\t\tconst arrPos = this._renderer.options.isVertical ? [0, pos] : [pos, 0];\n\n\t\tscrollTo(this._renderer.view, ...arrPos);\n\t}\n\tgetScrollPos() {\n\t\treturn this._prevPos;\n\t}\n\tsetScrollPos(pos) {\n\t\tlet rawPos = pos;\n\n\t\tif (typeof pos === \"undefined\") {\n\t\t\trawPos = this.getOrgScrollPos();\n\t\t}\n\t\tthis._prevPos = rawPos - this._renderer.getContainerOffset();\n\t}\n\tattachEvent() {\n\t\taddEvent(this._renderer.view, \"scroll\", this._onCheck);\n\t\taddEvent(window, \"resize\", this._onResize);\n\t}\n\tgetOrgScrollPos() {\n\t\treturn scroll(this._renderer.view, this._renderer.options.isVertical);\n\t}\n\treset() {\n\t\tthis._prevPos = null;\n\t}\n\t_onCheck() {\n\t\tconst prevPos = this.getScrollPos();\n\t\tconst orgScrollPos = this.getOrgScrollPos();\n\n\t\tthis.setScrollPos(orgScrollPos);\n\t\tconst scrollPos = this.getScrollPos();\n\n\t\tif (prevPos === null || (IS_IOS && orgScrollPos === 0) || prevPos === scrollPos) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._callback.check && this._callback.check({\n\t\t\tisForward: prevPos < scrollPos,\n\t\t\tscrollPos,\n\t\t\torgScrollPos,\n\t\t\thorizontal: !this._renderer.options.isVertical,\n\t\t});\n\t}\n\t_onResize() {\n\t\tif (this._timer.resize) {\n\t\t\tclearTimeout(this._timer.resize);\n\t\t}\n\t\tthis._timer.resize = setTimeout(() => {\n\t\t\tthis._renderer.isNeededResize() &&\n\t\t\t\tthis._callback.layout &&\n\t\t\t\tthis._callback.layout();\n\t\t\tthis._timer.resize = null;\n\t\t\tthis.reset();\n\t\t}, 100);\n\t}\n\tdetachEvent() {\n\t\tremoveEvent(window, \"resize\", this._onResize);\n\t}\n\tdestroy() {\n\t\tthis.detachEvent();\n\t\tthis.reset();\n\t}\n}\n\n","/**\n * Copyright (c) 2017 NAVER Corp.\n * egjs projects are licensed under the MIT license\n*/\nimport Component from \"@egjs/component\";\nimport ItemManager from \"./ItemManager\";\nimport DOMRenderer from \"./DOMRenderer\";\nimport ImageLoaded, {CHECK_ALL, CHECK_ONLY_ERROR} from \"./ImageLoaded\";\nimport Watcher from \"./Watcher\";\nimport AutoSizer from \"./AutoSizer\";\nimport {\n\tAPPEND,\n\tPREPEND,\n\tCACHE,\n\tNO_CACHE,\n\tTRUSTED,\n\tNO_TRUSTED,\n\tIS_ANDROID2,\n\tIDLE,\n\tLOADING_APPEND,\n\tLOADING_PREPEND,\n\tPROCESSING,\n\tDEFENSE_BROWSER,\n\tIGNORE_CLASSNAME,\n} from \"./consts\";\nimport {toArray, $, innerWidth, innerHeight, matchHTML} from \"./utils\";\n\n// IE8\n// https://stackoverflow.com/questions/43216659/babel-ie8-inherit-issue-with-object-create\n/* eslint-disable */\nif (typeof Object.create !== \"function\") {\n\tObject.create = function (o, properties) {\n\t\tif (typeof o !== \"object\" && typeof o !== \"function\") {\n\t\t\tthrow new TypeError(\"Object prototype may only be an Object: \" + o);\n\t\t} else if (o === null) {\n\t\t\tthrow new Error(\"This browser's implementation of Object.create is a shim and doesn't support 'null' as the first argument.\");\n\t\t}\n\t\tfunction F() {}\n\t\tF.prototype = o;\n\t\treturn new F();\n\t};\n}\n/* eslint-enable */\n\nfunction hasTarget(...targets) {\n\treturn targets.every(target => ~target[0].indexOf(target[1]));\n}\n\n/**\n * A module used to arrange card elements including content infinitely according to layout type. With this module, you can implement various layouts composed of different card elements whose sizes vary. It guarantees performance by maintaining the number of DOMs the module is handling under any circumstance\n * @ko          .         .        DOM      \n * @alias eg.InfiniteGrid\n * @extends eg.Component\n *\n * @example\n```\n<ul id=\"grid\">\n\t<li class=\"card\">\n\t\t<div>test1</div>\n\t</li>\n\t<li class=\"card\">\n\t\t<div>test2</div>\n\t</li>\n\t<li class=\"card\">\n\t\t<div>test3</div>\n\t</li>\n\t<li class=\"card\">\n\t\t<div>test4</div>\n\t</li>\n\t<li class=\"card\">\n\t\t<div>test5</div>\n\t</li>\n\t<li class=\"card\">\n\t\t<div>test6</div>\n\t</li>\n</ul>\n<script>\nvar some = new eg.InfiniteGrid(\"#grid\").on(\"layoutComplete\", function(e) {\n\t// ...\n});\n</script>\n```\n *\n * @support {\"ie\": \"8+\", \"ch\" : \"latest\", \"ff\" : \"latest\",  \"sf\" : \"latest\", \"edge\" : \"latest\", \"ios\" : \"7+\", \"an\" : \"2.1+ (except 3.x)\"}\n **/\nclass InfiniteGrid extends Component {\n\t/**\n\t * @param {HTMLElement|String|jQuery} element A base element for a module <ko>   </ko>\n\t * @param {Object} [options] The option object of the eg.InfiniteGrid module <ko>eg.InfiniteGrid   </ko>\n\t * @param {String} [options.itemSelector] A selector to select card elements that make up the layout<ko>     (selector)</ko>\n\t * @param {Boolean} [options.useRecycle=true] Indicates whether keep the number of DOMs is maintained. If the useRecycle value is 'true', keep the number of DOMs is maintained. If the useRecycle value is 'false', the number of DOMs will increase as card elements are added. <ko>DOM    . useRecycle  'true' DOM   . useRecycle  'false'     DOM   .</ko>\n\t * @param {Boolean} [options.isOverflowScroll=false] Indicates whether overflow:scroll is applied<ko>overflow:scroll  .</ko>\n\t * @param {Boolean} [options.horizontal=false] Direction of the scroll movement (true: horizontal, false: vertical) <ko>   (true , false )</ko>\n\t * @param {Boolean} [options.isEqualSize=false] Indicates whether sizes of all card elements are equal to one another. If sizes of card elements to be arranged are all equal and this option is set to \"true\", the performance of layout arrangement can be improved. <ko>    .          'true'       </ko>\n\t * @param {Number} [options.threshold=100] The threshold size of an event area where card elements are added to a layout.<ko>        .</ko>\n\t * @param {String} [options.attributePrefix=\"data-\"] The prefix to use element's data attribute.<ko>    .</ko>\n\t */\n\tconstructor(element, options) {\n\t\tsuper();\n\t\tObject.assign(this.options = {\n\t\t\titemSelector: \"*\",\n\t\t\tisOverflowScroll: false,\n\t\t\tthreshold: 100,\n\t\t\tisEqualSize: false,\n\t\t\tuseRecycle: true,\n\t\t\thorizontal: false,\n\t\t\tattributePrefix: \"data-\",\n\t\t}, options);\n\t\tIS_ANDROID2 && (this.options.isOverflowScroll = false);\n\t\tthis._isVertical = !this.options.horizontal;\n\t\tthis._reset();\n\t\tthis._items = new ItemManager();\n\t\tthis._renderer = new DOMRenderer(element, {\n\t\t\tisOverflowScroll: this.options.isOverflowScroll,\n\t\t\tisEqualSize: this.options.isEqualSize,\n\t\t\tisVertical: this._isVertical,\n\t\t});\n\t\tthis._loadingBar = {};\n\t\tthis._watcher = new Watcher(\n\t\t\tthis._renderer,\n\t\t\t{\n\t\t\t\tlayout: () => this.layout(),\n\t\t\t\tcheck: param => this._onCheck(param),\n\t\t\t});\n\t}\n\t/**\n\t * Adds a card element at the bottom of a layout. This method is available only if the isProcessing() method returns false.\n\t * @ko     . isProcessing()   'false'      \n\t *   isProcessing()  false   .\n\t * @param {Array|jQuery} elements Array of the card elements to be added <ko>   </ko>\n\t * @param {Number|String} [groupKey] The group key to be configured in a card element. It is automatically generated by default.\n\t * <ko>     .    .</ko>\n\t * @return {eg.InfiniteGrid} An instance of a module itself<ko>  </ko>\n\t * @example\n\t * infinitegrid.append(\"&lt;div class='item'&gt;test1&lt;/div&gt;&lt;div class='item'&gt;test2&lt;/div&gt;\");\n\t * infinitegrid.append([\"&lt;div class='item'&gt;test1&lt;/div&gt;\", \"&lt;div class='item'&gt;test2&lt;/div&gt;\"]);\n\t * infinitegrid.append([HTMLElement1, HTMLElement2]);\n\t * infinitegrid.append(jQuery([\"&lt;div class='item'&gt;test1&lt;/div&gt;\", \"&lt;div class='item'&gt;test2&lt;/div&gt;\"]));\n\t */\n\tappend(elements, groupKey) {\n\t\tthis._layout && this._insert(elements, APPEND, groupKey);\n\t\treturn this;\n\t}\n\t/**\n\t * Adds a card element at the top of a layout. This method is available only if the isProcessing() method returns false.\n\t * @ko     . isProcessing()   'false'      \n\t * @param {Array|jQuery} elements Array of the card elements to be added <ko>   </ko>\n\t * @param {Number|String} [groupKey] The group key to be configured in a card element. It is automatically generated by default.\n\t * <ko>     .    .</ko>\n\t * @return {eg.InfiniteGrid} An instance of a module itself<ko>  </ko>\n\t * @example\n\t * infinitegrid.prepend(\"&lt;div class='item'&gt;test1&lt;/div&gt;&lt;div class='item'&gt;test2&lt;/div&gt;\");\n\t * infinitegrid.prepend([\"&lt;div class='item'&gt;test1&lt;/div&gt;\", \"&lt;div class='item'&gt;test2&lt;/div&gt;\"]);\n\t * infinitegrid.prepend([HTMLElement1, HTMLElement2]);\n\t * infinitegrid.prepend(jQuery([\"&lt;div class='item'&gt;test1&lt;/div&gt;\", \"&lt;div class='item'&gt;test2&lt;/div&gt;\"]));\n\t */\n\tprepend(elements, groupKey) {\n\t\tthis._layout && this._insert(elements, PREPEND, groupKey);\n\t\treturn this;\n\t}\n\t/**\n\t * Specifies the Layout class to use.\n\t * @ko  Layout  .\n\t * @param {Class|Object} LayoutKlass The Layout class to use or an instance of a layout moudle<ko> Layout     </ko>\n\t * @param {Object} options Options to apply to the Layout.<ko>Layout  </ko>\n\t * @return {eg.InfiniteGrid} An instance of a module itself<ko>  </ko>\n\t * @example\n\t * infinitegrid.setLayout(eg.InfiniteGrid.GridLayout, {\n\t *  margin: 10,\n\t *  align: \"start\"\n\t * });\n   * infinitegrid.setLayout(eg.InfiniteGrid.JustifiedLayout, {\n\t *  margin: 10,\n\t *  minSize: 100,\n\t *  maxSize: 200\n\t * });\n   * infinitegrid.setLayout(eg.InfiniteGrid.SquareLayout, {\n\t *  margin: 10,\n\t *  column: 2\n\t * });\n\t * infinitegrid.setLayout(eg.InfiniteGrid.FrameLayout, {\n\t *  margin: 10,\n\t *  frame: [\n\t *   [1, 2],\n   *   [4, 3],\n\t *  ]\n\t * });\n\t * infinitegrid.setLayout(eg.InfiniteGrid.PackingLayout, {\n\t *  margin: 10,\n\t *  aspectRatio: 1.5\n\t * });\n\t * var layout = new eg.InfiniteGrid.GridLayout({\n\t * \tmargin: 10,\n\t *\talign: \"start\"\n\t * });\n\t * infinitegrid.setLayout(layout);\n\t */\n\tsetLayout(LayoutKlass, options) {\n\t\tif (typeof LayoutKlass === \"function\") {\n\t\t\tthis._layout = new LayoutKlass(Object.assign(options || {}, {\n\t\t\t\thorizontal: !this._isVertical,\n\t\t\t}));\n\t\t} else {\n\t\t\tthis._layout = LayoutKlass;\n\t\t\tthis._layout.options.horizontal = !this._isVertical;\n\t\t}\n\t\tthis._layout.setSize(this._renderer.getViewportSize());\n\t\treturn this;\n\t}\n\t/**\n\t * Returns the layouted items.\n\t * @ko   .\n\t * @param {Boolean} includeCached Indicates whether to include the cached items. <ko>    .</ko>\n\t * @returns {Array} List of items <ko> </ko>\n\t */\n\tgetItems(includeCached = false) {\n\t\treturn this[includeCached ? \"_getItems\" : \"_getVisibleItems\"]();\n\t}\n\t_getItems() {\n\t\treturn this._items.pluck(\"items\", 0, this._items.size());\n\t}\n\t_getVisibleItems() {\n\t\treturn this._items.pluck(\"items\", this._status.startCursor, this._status.endCursor);\n\t}\n\t_updateEdge() {\n\t\tthis._status.start = this._items.getEdge(\"start\", this._status.startCursor, this._status.endCursor);\n\t\tthis._status.end = this._items.getEdge(\"end\", this._status.startCursor, this._status.endCursor);\n\t}\n\t_getEdgeOffset(cursor) {\n\t\tlet rect = null;\n\n\t\tif (!this._status[cursor]) {\n\t\t\tconst item = this._items.getEdge(cursor);\n\n\t\t\tthis._status[cursor] = item;\n\t\t}\n\n\t\tif (this._status[cursor]) {\n\t\t\trect = this._status[cursor].rect;\n\t\t\tif (cursor === \"start\") {\n\t\t\t\trect.bottom = rect.top + this._status[cursor].size.height;\n\t\t\t\trect.right = rect.left + this._status[cursor].size.width;\n\t\t\t}\n\t\t}\n\t\treturn rect;\n\t}\n\t// called by visible\n\t_fit(scrollCycle = \"after\") {\n\t\t// for caching\n\t\tif (!this._layout) {\n\t\t\treturn 0;\n\t\t}\n\t\tconst base = this._getEdgeValue(\"start\");\n\t\tconst margin = (this._getLoadingStatus() === LOADING_PREPEND && this._status.loadingSize) || 0;\n\n\t\tif (!this.options.useRecycle || DEFENSE_BROWSER) {\n\t\t\tif (scrollCycle === \"before\" && margin && base < margin) {\n\t\t\t\tthis._renderer.scrollBy(-Math.abs(base) + margin);\n\t\t\t\tthis._watcher.setScrollPos();\n\t\t\t\tthis._items.fit(base - margin, this._isVertical);\n\t\t\t\tDOMRenderer.renderItems(this._getVisibleItems());\n\t\t\t\tthis._renderer.setContainerSize(this._getEdgeValue(\"end\") || margin);\n\t\t\t} else if (scrollCycle === \"after\" && base < 0) {\n\t\t\t\tthis._items.fit(base - margin, this._isVertical);\n\t\t\t\tthis._renderer.setContainerSize(this._getEdgeValue(\"end\") || margin);\n\t\t\t\tDOMRenderer.renderItems(this._getVisibleItems());\n\t\t\t\tthis._renderer.scrollBy(Math.abs(base));\n\t\t\t\tthis._watcher.setScrollPos();\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (base !== 0 || margin) {\n\t\t\tconst isProcessing = this._isProcessing();\n\n\t\t\tthis._process(PROCESSING);\n\t\t\tif (scrollCycle === \"before\") {\n\t\t\t\tthis._renderer.scrollBy(-Math.abs(base) + margin);\n\t\t\t\tthis._watcher.setScrollPos();\n\t\t\t}\n\t\t\tthis._items.fit(base - margin, this._isVertical);\n\t\t\tDOMRenderer.renderItems(this._getVisibleItems());\n\t\t\tthis._renderer.setContainerSize(this._getEdgeValue(\"end\") || margin);\n\t\t\tif (scrollCycle === \"after\") {\n\t\t\t\tthis._renderer.scrollBy(Math.abs(base) + margin);\n\t\t\t\tthis._watcher.setScrollPos();\n\t\t\t}\n\t\t\tif (!isProcessing) {\n\t\t\t\tthis._process(PROCESSING, false);\n\t\t\t}\n\t\t}\n\t\treturn base;\n\t}\n\t_getEdgeValue(cursor) {\n\t\treturn this._items.getEdgeValue(cursor, this._status.startCursor, this._status.endCursor);\n\t}\n\t/**\n\t * Rearranges a layout.\n\t * @ko   .\n\t * @param {Boolean} [isRelayout=true] Indicates whether a card element is being relayouted <ko>   </ko>\n\t * @return {eg.InfiniteGrid} An instance of a module itself<ko>  </ko>\n\t */\n\tlayout(isRelayout = true) {\n\t\tif (!this._layout) {\n\t\t\treturn this;\n\t\t}\n\t\t// check childElement\n\t\tif (!this._items.size()) {\n\t\t\tthis._insert(toArray(this._renderer.container.children), true);\n\t\t\treturn this;\n\t\t}\n\t\tlet data;\n\t\tlet outline;\n\n\t\tif (isRelayout) { // remove cache\n\t\t\tif (this.options.isEqualSize) {\n\t\t\t\tthis._renderer.updateSize([this._status.start]);\n\t\t\t\tdata = this._items.get(0, this._status.endCursor);\n\t\t\t\toutline = this._items.getOutline(0, \"start\");\n\t\t\t} else {\n\t\t\t\tdata = this._items.get(this._status.startCursor, this._status.endCursor);\n\t\t\t}\n\t\t\tif (this._renderer.resize()) {\n\t\t\t\tthis._layout.setSize(this._renderer.getViewportSize());\n\t\t\t\tdata.forEach(v => {\n\t\t\t\t\tdata.items = this._renderer.updateSize(v.items);\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tdata = this._items.get(this._status.startCursor, this._items.size());\n\t\t\toutline = this._items.getOutline(this._status.startCursor, \"start\");\n\t\t}\n\t\tif (!data.length) {\n\t\t\treturn this;\n\t\t}\n\t\tthis._layout.layout(data, outline);\n\n\t\tif (isRelayout) {\n\t\t\tif (!this.options.isEqualSize) {\n\t\t\t\tthis._items._data.forEach((group, cursor) => {\n\t\t\t\t\tif (this._status.startCursor <= cursor && cursor <= this._status.endCursor) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tgroup.outlines.start = [];\n\t\t\t\t\tgroup.outlines.end = [];\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis._fit(\"after\");\n\t\t\t}\n\t\t} else {\n\t\t\tdata.forEach(v => this._items.set(v, v.groupKey));\n\t\t}\n\t\tthis._onLayoutComplete(data, APPEND, NO_TRUSTED, false, true);\n\t\tDOMRenderer.renderItems(this._getVisibleItems());\n\t\tisRelayout && this._watcher.setScrollPos();\n\n\t\treturn this;\n\t}\n\t/**\n\t * Removes a item element on a grid layout.\n\t * @ko     .\n\t * @param {HTMLElement} item element to be removed <ko>  </ko>\n\t * @return {Object}  Removed item element <ko>   </ko>\n\t */\n\tremove(element) {\n\t\tif (element) {\n\t\t\tconst items = this._items.remove(element, this._status.startCursor, this._status\n\t\t\t\t.endCursor);\n\n\t\t\tif (items) {\n\t\t\t\tDOMRenderer.removeElement(element);\n\t\t\t\treturn items;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\t_getNextItems(isAppend) {\n\t\tlet items = [];\n\t\tconst size = this._items.size();\n\n\t\t// from cache\n\t\tif (size > 0 && this._status.startCursor !== -1 && this._status.endCursor !==\n\t\t\t-1) {\n\t\t\tif (isAppend && size > this._status.endCursor + 1) {\n\t\t\t\titems = this._items.pluck(\"items\", this._status.endCursor + 1);\n\t\t\t} else if (!isAppend && this._status.startCursor > 0) {\n\t\t\t\titems = this._items.pluck(\"items\", this._status.startCursor - 1);\n\t\t\t}\n\t\t}\n\t\treturn items;\n\t}\n\t/**\n\t * Returns the list of group keys which belongs to card elements currently being maintained. You can use the append() or prepend() method to configure group keys so that multiple card elements can be managed at once. If you do not use these methods to configure group keys, groupkey is automatically generated.\n\t * @ko         .         append()  prepend()      . append()  prepend()        .\n\t * @param {Boolean} includeCached Indicates whether to include the cached groups. <ko>    .</ko>\n\t * @return {Array} List of group keys <ko>  </ko>\n\t */\n\tgetGroupKeys(includeCached) {\n\t\tconst data = includeCached ?\n\t\t\tthis._items.get() : this._items.get(this._status.startCursor, this._status.endCursor);\n\n\t\treturn data.map(v => v.groupKey);\n\t}\n\t/**\n\t * Returns the current state of a module such as location information. You can use the setStatus() method to restore the information returned through a call to this method.\n\t * @ko         .       setStatus()    \n\t * @return {Object} State object of the eg.InfiniteGrid module<ko>eg.InfiniteGrid   </ko>\n\t */\n\tgetStatus() {\n\t\treturn {\n\t\t\toptions: Object.assign({}, this.options),\n\t\t\t_status: Object.assign({}, this._status),\n\t\t\t_items: this._items.getStatus(),\n\t\t\t_renderer: this._renderer.getStatus(),\n\t\t\t_watcher: this._watcher.getStatus(),\n\t\t};\n\t}\n\t/**\n\t * Sets the state of the eg.InfiniteGrid module with the information returned through a call to the getStatue() method.\n\t * @ko getStatue()    eg.InfiniteGrid   .\n\t * @param {Object} status State object of the eg.InfiniteGrid module <ko>eg.InfiniteGrid   </ko>\n\t * @param {boolean} [applyScrollPos=true] Checks whether to scroll<ko>   .</ko>\n\t * @return {eg.InfiniteGrid} An instance of a module itself<ko>  </ko>\n\t */\n\tsetStatus(status, applyScrollPos = true) {\n\t\tif (!status || !status.options || !status._status ||\n\t\t\t!status._renderer || !status._items || !status._watcher) {\n\t\t\treturn this;\n\t\t}\n\t\tthis._watcher.detachEvent();\n\t\tObject.assign(this.options, status.options);\n\t\tObject.assign(this._status, status._status);\n\t\tthis._items.setStatus(status._items, this._status.startCursor, this._status.endCursor);\n\t\tthis._renderer.setStatus(status._renderer, this._getVisibleItems());\n\t\tthis._watcher.setStatus(status._watcher, applyScrollPos);\n\t\tthis._updateEdge();\n\t\tthis._watcher.attachEvent();\n\t\treturn this;\n\t}\n\t/**\n\t * Clears added card elements and data.\n\t * @ko      .\n\t * @return {eg.InfiniteGrid} An instance of a module itself<ko>  </ko>\n\t */\n\tclear() {\n\t\tthis._items.clear();\n\t\tthis._renderer.clear();\n\t\tthis._reset();\n\t\tthis._appendLoadingBar();\n\t\treturn this;\n\t}\n\t/**\n\t * Specifies the Loading Bar to use for append or prepend items.\n\t * @ko  append  prepend      .\n\t * @param {String|Object} [userLoadingBar={}] The loading bar HTML markup or element or element selector <ko>   HTML  element  selector </ko>\n\t * @return {eg.InfiniteGrid} An instance of a module itself<ko>  </ko>\n\t */\n\tsetLoadingBar(userLoadingBar = {}) {\n\t\tconst loadingBarObj = typeof userLoadingBar === \"object\" ? userLoadingBar : {\n\t\t\t\"append\": userLoadingBar,\n\t\t\t\"prepend\": userLoadingBar,\n\t\t};\n\n\t\tthis._status.loadingSize = 0;\n\t\tthis._status.loadingStyle = {};\n\t\tconst loadingBar = this._loadingBar;\n\n\t\tfor (const type in loadingBarObj) {\n\t\t\tloadingBar[type] = $(loadingBarObj[type]);\n\t\t\tloadingBar[type].className += ` ${IGNORE_CLASSNAME}`;\n\t\t}\n\t\tthis._appendLoadingBar();\n\t\treturn this;\n\t}\n\t_appendLoadingBar() {\n\t\tconst loadingBar = this._loadingBar;\n\t\tconst container = this._renderer.container;\n\n\t\tfor (const type in loadingBar) {\n\t\t\tcontainer.appendChild(loadingBar[type]);\n\t\t}\n\t}\n\t/**\n\t * Checks whether a card element or data is being added.\n\t * @ko         \n\t * @return {Boolean} Indicates whether a card element or data is being added <ko>        </ko>\n\t */\n\tisProcessing() {\n\t\treturn this._isProcessing() || this._isLoading();\n\t}\n\t_isProcessing() {\n\t\treturn (this._status.processingStatus & PROCESSING) > 0;\n\t}\n\t_isLoading() {\n\t\treturn this._getLoadingStatus() > 0;\n\t}\n\t_getLoadingStatus() {\n\t\treturn this._status.processingStatus & (LOADING_APPEND | LOADING_PREPEND);\n\t}\n\t_process(status, isAdd = true) {\n\t\tif (isAdd) {\n\t\t\tthis._status.processingStatus |= status;\n\t\t} else {\n\t\t\tthis._status.processingStatus -= this._status.processingStatus & status;\n\t\t}\n\t}\n\t_insert(elements, isAppend, groupKey) {\n\t\tif (this._isProcessing() || elements.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tconst key = typeof groupKey === \"undefined\" ? (new Date().getTime() + Math\n\t\t\t.floor(\n\t\t\t\tMath.random() * 1000)) : groupKey;\n\t\tconst items = ItemManager.from($(elements, true), this.options.itemSelector, {\n\t\t\tisAppend,\n\t\t\tgroupKey: key,\n\t\t});\n\n\t\tif (!items.length) {\n\t\t\treturn;\n\t\t}\n\t\tthis._postLayout(NO_CACHE, items, isAppend, NO_TRUSTED);\n\t}\n\t// add items, and remove items for recycling\n\t_recycle(isAppend) {\n\t\tconst remove = [];\n\n\t\tif (this._status.startCursor !== this._status.endCursor) {\n\t\t\tfor (let i = this._status.startCursor; i <= this._status.endCursor; i++) {\n\t\t\t\tremove.push(this._isVisible(i));\n\t\t\t}\n\t\t}\n\t\tlet start = remove.indexOf(isAppend ? 1 : -1);\n\t\tlet end = remove.lastIndexOf(isAppend ? 1 : -1);\n\t\tconst visible = remove.indexOf(0);\n\n\t\tif (visible === -1 || start === -1 || end === -1) {\n\t\t\treturn;\n\t\t}\n\n\t\tstart = this._status.startCursor + (isAppend ? 0 : start);\n\t\tend = (isAppend ? this._status.startCursor + end : this._status.endCursor);\n\t\tDOMRenderer.removeItems(this._items.pluck(\"items\", start, end));\n\t\tif (isAppend) {\n\t\t\tthis._status.startCursor = end + 1;\n\t\t} else {\n\t\t\tthis._status.endCursor = start - 1;\n\t\t}\n\t}\n\t/**\n\t * Returns the element of loading bar.\n\t * @ko   element .\n\t * @param {Boolean} [isAppend=currentLoadingBar|true] Checks whether the card element is added to the append () method. <ko>  append()     .</ko>\n\t * @return {Element} The element of loading bar. <ko>  element</ko>\n\t */\n\tgetLoadingBar(isAppend = this._getLoadingStatus() !== LOADING_PREPEND) {\n\t\treturn this._loadingBar[isAppend ? \"append\" : \"prepend\"];\n\t}\n\t/**\n\t * Start loading for append/prepend during loading data.\n\t * @ko    append/prepend   .\n\t * @param {Boolean} [isAppend=true] Checks whether the card element is added to the append () method. <ko>  append()     .</ko>\n\t * @param {Object} [userStyle = {display: \"block\"}] custom style to apply to this loading bar for start. <ko>         </ko>\n\t * @return {eg.InfiniteGrid} An instance of a module itself<ko>  </ko>\n\t */\n\tstartLoading(isAppend, userStyle = {display: \"block\"}) {\n\t\tif (this._isLoading()) {\n\t\t\treturn this;\n\t\t}\n\t\tconst type = isAppend ? \"append\" : \"prepend\";\n\n\t\tthis._process(isAppend ? LOADING_APPEND : LOADING_PREPEND);\n\t\tif (!this._loadingBar[type]) {\n\t\t\treturn this;\n\t\t}\n\t\tthis._renderLoading(userStyle);\n\t\tthis._status.loadingStyle = userStyle;\n\t\tif (!isAppend) {\n\t\t\tthis._fit(\"before\");\n\t\t} else {\n\t\t\tthis._renderer.setContainerSize(this._getEdgeValue(\"end\") + this._status.loadingSize);\n\t\t}\n\t\treturn this;\n\t}\n\t_renderLoading(userStyle = this._status.loadingStyle) {\n\t\tif (!this._isLoading()) {\n\t\t\treturn;\n\t\t}\n\t\tconst isAppend = this._getLoadingStatus() === LOADING_APPEND;\n\t\tconst el = this._loadingBar[isAppend ? \"append\" : \"prepend\"];\n\n\t\tif (!el) {\n\t\t\treturn;\n\t\t}\n\t\tthis._status.loadingSize = this._isVertical ? innerHeight(el) : innerWidth(el);\n\t\tconst pos = isAppend ? this._getEdgeValue(\"end\") : this._getEdgeValue(\"start\") - this._status.loadingSize;\n\t\tconst style = Object.assign({\n\t\t\tposition: \"absolute\",\n\t\t\t[this._isVertical ? \"top\" : \"left\"]: `${pos}px`,\n\t\t}, userStyle);\n\n\t\tfor (const property in style) {\n\t\t\tel.style[property] = style[property];\n\t\t}\n\t}\n\t/**\n\t * End loading after startLoading() for append/prepend\n\t * @ko  append/prepend  startLoading()    .\n\t * @param {Object} [userStyle = {display: \"none\"}] custom style to apply to this loading bar for end <ko>         </ko>\n\t * @return {eg.InfiniteGrid} An instance of a module itself<ko>  </ko>\n\t */\n\tendLoading(userStyle = {display: \"none\"}) {\n\t\tif (!this._isLoading()) {\n\t\t\treturn this;\n\t\t}\n\t\tconst isAppend = this._getLoadingStatus() === LOADING_APPEND;\n\t\tconst type = isAppend ? \"append\" : \"prepend\";\n\t\tconst el = this._loadingBar[type];\n\t\tconst size = this._status.loadingSize;\n\n\t\tthis._process(LOADING_APPEND | LOADING_PREPEND, false);\n\t\tthis._status.loadingSize = 0;\n\t\tthis._status.loadingStyle = {};\n\t\tif (!el) {\n\t\t\treturn this;\n\t\t}\n\t\tconst style = Object.assign({\n\t\t\t[this._isVertical ? \"top\" : \"left\"]: `${-size}px`,\n\t\t}, userStyle);\n\n\t\tfor (const property in style) {\n\t\t\tel.style[property] = style[property];\n\t\t}\n\t\tif (!isAppend && this.options.useRecycle && !DEFENSE_BROWSER) {\n\t\t\tthis._renderer.scrollBy(-size);\n\t\t\tthis._watcher.setScrollPos();\n\t\t\tthis._items.fit(size, this._isVertical);\n\t\t\tDOMRenderer.renderItems(this._getVisibleItems());\n\t\t\tthis._renderer.setContainerSize(this._getEdgeValue(\"end\"));\n\t\t}\n\t\tthis._renderer.setContainerSize(this._getEdgeValue(\"end\"));\n\t\treturn this;\n\t}\n\t_postImageLoaded(fromCache, layouted, isAppend, isTrusted) {\n\t\tif (fromCache) {\n\t\t\tthis._setItems(layouted);\n\t\t} else {\n\t\t\tthis._insertItems(layouted, isAppend);\n\t\t}\n\t\tthis._updateCursor(isAppend);\n\t\tDOMRenderer.renderItems(layouted.items);\n\t\tthis._onLayoutComplete(layouted.items, isAppend, isTrusted, false);\n\t}\n\t_onImageError(target, item, itemIndex, removeTarget, replaceTarget) {\n\t\tconst element = item.el;\n\t\tconst prefix = this.options.attributePrefix;\n\n\t\titem.content = element.outerHTML;\n\n\t\tconst removeItem = () => {\n\t\t\tif (hasTarget([removeTarget, element])) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tremoveTarget.push(element);\n\t\t\tconst index = replaceTarget.indexOf(itemIndex);\n\n\t\t\tif (index !== -1) {\n\t\t\t\treplaceTarget.splice(index, 1);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * This event is fired when an error occurs in the image.\n\t\t * @ko       .\n\t\t * @event eg.InfiniteGrid#imageError\n\t\t * @param {Object} param The object of data to be sent to an event <ko>   </ko>\n\t\t * @param {Element} param.target Appending card's image element.<ko>    </ko>\n\t\t * @param {Element} param.elememt The item's element with error images.<ko>     </ko>\n\t\t * @param {Object} param.item The item with error images.<ko>    </ko>\n\t\t * @param {Number} param.itemIndex The item's index with error images.<ko>     </ko>\n\t\t * @param {Function} param.remove In the imageError event, this method expects to remove the error image.<ko>       .</ko>\n\t\t * @param {Function} param.removeItem In the imageError event, this method expects to remove the item with the error image.<ko>          .</ko>\n\t\t * @param {Function} param.replace In the imageError event, this method expects to replace the error image's source or element.<ko>          .</ko>\n\t\t * @param {Function} param.replaceItem In the imageError event, this method expects to replace the item's contents with the error image.<ko>           .</ko>\n\t\t * @example\nig.on(\"imageError\", e => {\n\te.remove();\n\te.removeItem();\n\te.replace(\"http://...jpg\");\n\te.replace(imageElement);\n\te.replaceItem(\"item html\");\n});\n\t\t */\n\t\tthis.trigger(\"imageError\", {\n\t\t\ttarget,\n\t\t\telement,\n\t\t\titem,\n\t\t\titemIndex,\n\t\t\t// remove item\n\t\t\tremoveItem,\n\t\t\t// remove image\n\t\t\tremove: () => {\n\t\t\t\tif (target === element) {\n\t\t\t\t\tremoveItem();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (hasTarget([removeTarget, element])) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ttarget.parentNode.removeChild(target);\n\t\t\t\titem.content = element.outerHTML;\n\t\t\t\tif (hasTarget([replaceTarget, itemIndex])) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\treplaceTarget.push(itemIndex);\n\t\t\t},\n\t\t\t// replace image\n\t\t\treplace: src => {\n\t\t\t\tif (hasTarget([removeTarget, element])) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (src) {\n\t\t\t\t\tif (matchHTML(src) || typeof src === \"object\") {\n\t\t\t\t\t\tconst parentNode = target.parentNode;\n\n\t\t\t\t\t\tparentNode.insertBefore($(src), target);\n\t\t\t\t\t\tparentNode.removeChild(target);\n\t\t\t\t\t\titem.content = element.outerHTML;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget.src = src;\n\t\t\t\t\t\tif (target.getAttribute(`${prefix}width`)) {\n\t\t\t\t\t\t\tAutoSizer.remove(target);\n\t\t\t\t\t\t\ttarget.removeAttribute(`${prefix}width`);\n\t\t\t\t\t\t\ttarget.removeAttribute(`${prefix}height`);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\titem.content = element.outerHTML;\n\t\t\t\tif (hasTarget([replaceTarget, itemIndex])) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\treplaceTarget.push(itemIndex);\n\t\t\t},\n\t\t\t// replace item\n\t\t\treplaceItem: content => {\n\t\t\t\tif (hasTarget([removeTarget, element], [replaceTarget, itemIndex])) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\telement.innerHTML = content;\n\t\t\t\titem.content = element.outerHTML;\n\t\t\t\treplaceTarget.push(itemIndex);\n\t\t\t},\n\t\t});\n\t}\n\t_postImageLoadedEnd(layouted, isAppend, removeTarget, replaceTarget) {\n\t\tif (!removeTarget.length && !replaceTarget.length) {\n\t\t\tif (!this.isProcessing() && this.options.useRecycle) {\n\t\t\t\tthis._recycle(isAppend);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tconst prefix = this.options.attributePrefix;\n\t\tconst layoutedItems = replaceTarget.map(itemIndex => layouted.items[itemIndex]);\n\n\t\tremoveTarget.forEach(element => {\n\t\t\tthis.remove(element);\n\t\t});\n\t\tif (this.options.isEqualSize) {\n\t\t\tif (removeTarget.length > 0) {\n\t\t\t\tthis.layout(false);\n\t\t\t} else if (!this.isProcessing() && this.options.useRecycle) {\n\t\t\t\tthis._recycle(isAppend);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t// wait layoutComplete beacause of error event.\n\t\tImageLoaded.check(layoutedItems.map(v => v.el), {\n\t\t\tprefix,\n\t\t\tcomplete: () => {\n\t\t\t\tthis._renderer.updateSize(layoutedItems);\n\t\t\t\tthis.layout(false);\n\t\t\t},\n\t\t});\n\t}\n\t_postLayout(fromCache, items, isAppend, isTrusted) {\n\t\tconst {startCursor, endCursor} = this._status;\n\t\tconst outline = this._items.getOutline(\n\t\t\tisAppend ? endCursor : startCursor,\n\t\t\tisAppend ? \"end\" : \"start\");\n\n\t\tlet fromRelayout = false;\n\n\t\tif (fromCache) {\n\t\t\tconst cacheOutline = this._items.getOutline(\n\t\t\t\tisAppend ? endCursor + 1 : startCursor - 1,\n\t\t\t\tisAppend ? \"start\" : \"end\");\n\n\t\t\tfromRelayout = outline.length === cacheOutline.length ?\n\t\t\t\t!outline.every((v, index) => v === cacheOutline[index]) : true;\n\n\t\t\tif (!fromRelayout) {\n\t\t\t\tthis._renderer.createAndInsert(items, isAppend);\n\t\t\t\tthis._updateCursor(isAppend);\n\t\t\t\tthis._onLayoutComplete(items, isAppend, isTrusted);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis._process(PROCESSING);\n\t\tconst method = isAppend ? \"append\" : \"prepend\";\n\n\t\tfromCache && DOMRenderer.createElements(items);\n\t\tthis._renderer[method](items);\n\n\t\t// check image sizes after elements are attated on DOM\n\t\tconst type = this.options.isEqualSize && this._renderer._size.item ? CHECK_ONLY_ERROR : CHECK_ALL;\n\t\tconst prefix = this.options.attributePrefix;\n\t\tconst replaceTarget = [];\n\t\tconst removeTarget = [];\n\t\tlet layouted;\n\n\t\tImageLoaded.check(items.map(item => item.el), {\n\t\t\tprefix,\n\t\t\ttype,\n\t\t\tcomplete: () => {\n\t\t\t\tlayouted = this._layout[method](\n\t\t\t\t\tthis._renderer.updateSize(items),\n\t\t\t\t\tthis._items.getOutline(\n\t\t\t\t\t\tisAppend ? endCursor : startCursor,\n\t\t\t\t\t\tisAppend ? \"end\" : \"start\")\n\t\t\t\t);\n\t\t\t\tthis._postImageLoaded(fromCache, layouted, isAppend, isTrusted);\n\t\t\t},\n\t\t\terror: ({target, itemIndex}) => {\n\t\t\t\tconst item = ((layouted && layouted.items) || items)[itemIndex];\n\n\t\t\t\tthis._onImageError(target, item, itemIndex, removeTarget, replaceTarget);\n\t\t\t},\n\t\t\tend: () => {\n\t\t\t\tthis._postImageLoadedEnd(layouted, isAppend, removeTarget, replaceTarget);\n\t\t\t},\n\t\t});\n\t\treturn this;\n\t}\n\t_isVisible(index) {\n\t\tconst min = Math.min(...this._items.getOutline(index, \"start\"));\n\t\tconst max = Math.max(...this._items.getOutline(index, \"end\"));\n\t\tconst pos = this._watcher.getScrollPos();\n\t\tconst viewSize = this._renderer.getViewSize();\n\n\t\tif (pos + viewSize + this.options.threshold < min) {\n\t\t\treturn -1;\n\t\t} else if (pos - this.options.threshold > max) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\t_updateCursor(isAppend) {\n\t\tif (this.options.useRecycle) {\n\t\t\tif (isAppend) {\n\t\t\t\tthis._status.endCursor++;\n\t\t\t} else if (this._status.startCursor > 0) {\n\t\t\t\tthis._status.startCursor--;\n\t\t\t} else {\n\t\t\t\tthis._status.endCursor++; // outside prepend\n\t\t\t}\n\t\t\tif (this._status.startCursor < 0) {\n\t\t\t\tthis._status.startCursor = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tthis._status.startCursor = 0;\n\t\t\tthis._status.endCursor = this._items.size() - 1;\n\t\t}\n\t}\n\t_setItems(layouted,\n\t\tgroupKey = (layouted.items && layouted.items[0].groupKey) || 0) {\n\t\tlayouted.groupKey = groupKey;\n\t\tthis._items.set(layouted, groupKey);\n\t}\n\t_insertItems(layouted, isAppend) {\n\t\tlayouted.groupKey = layouted.items[0].groupKey;\n\t\tthis._items[isAppend ? \"append\" : \"prepend\"](layouted);\n\t}\n\t// called by visible\n\t_requestAppend() {\n\t\tconst items = this._getNextItems(APPEND);\n\n\t\tif (this._isProcessing()) {\n\t\t\treturn;\n\t\t}\n\t\tif (items.length) {\n\t\t\tthis._postLayout(CACHE, items, APPEND, TRUSTED);\n\t\t} else {\n\t\t\t/**\n\t\t\t * This event is fired when a card element must be added at the bottom or right of a layout because there is no card to be displayed on screen when a user scrolls near bottom or right.\n\t\t\t * @ko          .          \n\t\t\t * @event eg.InfiniteGrid#append\n\t\t\t * @param {Object} param The object of data to be sent to an event <ko>   </ko>\n\t\t\t * @param {String|Number} groupKey The group key of the first group visible on the screen <ko>    </ko>\n\t\t\t * @param {Boolean} param.isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>     true,  API    false .</ko>\n\t\t\t */\n\t\t\tthis.trigger(\"append\", {\n\t\t\t\tisTrusted: true,\n\t\t\t\tgroupKey: this.getGroupKeys().pop(),\n\t\t\t});\n\t\t}\n\t}\n\t// called by visible\n\t_requestPrepend() {\n\t\tconst items = this._getNextItems(PREPEND);\n\n\t\tif (this._isProcessing()) {\n\t\t\treturn;\n\t\t}\n\t\tif (items.length) {\n\t\t\tthis._postLayout(CACHE, items, PREPEND, TRUSTED);\n\t\t} else {\n\t\t\t/**\n\t\t\t * This event is fired when a card element must be added at the top or left of a layout because there is no card to be displayed on screen when a user scrolls near top or left.\n\t\t\t * @ko         .          .\n\t\t\t * @event eg.InfiniteGrid#prepend\n\t\t\t * @param {Object} param The object of data to be sent to an event <ko>   </ko>\n\t\t\t * @param {String|Number} groupKey The group key of the first group visible on the screen <ko>    </ko>\n\t\t\t * @param {Boolean} param.isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>     true,  API    false .</ko>\n\t\t\t */\n\t\t\tthis.trigger(\"prepend\", {\n\t\t\t\tisTrusted: true,\n\t\t\t\tgroupKey: this.getGroupKeys().shift(),\n\t\t\t});\n\t\t}\n\t}\n\t_onCheck({isForward, scrollPos, horizontal, orgScrollPos}) {\n\t\t/**\n\t\t * This event is fired when the user scrolls.\n\t\t * @ko      .\n\t\t * @event eg.InfiniteGrid#change\n\t\t * @param {Object} param The object of data to be sent to an event <ko>   </ko>\n\t\t * @param {Boolean} param.isForward Indicates whether the scroll progression direction is forward or backword. <ko>    ,   .</ko>\n\t\t * @param {Number} param.scrollPos Current scroll position value relative to the infiniteGrid container element. <ko>infiniteGrid      </ko>\n\t\t * @param {Boolean} param.orgScrollPos Current position of the scroll <ko>  </ko>\n\t\t * @param {Boolean} param.isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>     true,  API    false .</ko>\n\t\t * @param {Boolean} options.horizontal Direction of the scroll movement (true: horizontal, false: vertical) <ko>   (true , false </ko>\n\t\t */\n\t\tthis.trigger(\"change\", {\n\t\t\tisForward,\n\t\t\thorizontal,\n\t\t\tscrollPos,\n\t\t\torgScrollPos,\n\t\t});\n\t\tconst rect = this._getEdgeOffset(isForward ? \"end\" : \"start\");\n\t\tconst isProcessing = this.isProcessing();\n\n\t\tif (!rect) {\n\t\t\treturn;\n\t\t}\n\t\tconst threshold = this.options.threshold;\n\t\tconst targetPos = isForward ?\n\t\t\trect[horizontal ? \"left\" : \"top\"] - this._renderer.getViewSize() :\n\t\t\trect[horizontal ? \"right\" : \"bottom\"];\n\n\t\tif (!isProcessing && isForward) {\n\t\t\tif (scrollPos + threshold >= targetPos) {\n\t\t\t\tthis._requestAppend();\n\t\t\t}\n\t\t} else if (scrollPos <= targetPos + threshold) {\n\t\t\tthis._fit(\"before\");\n\t\t\tthis._requestPrepend();\n\t\t}\n\t}\n\t_onLayoutComplete(items, isAppend, isTrusted = false,\n\t\tuseRecycle = this.options.useRecycle, isLayout = false) {\n\t\tthis._isLoading() && this._renderLoading();\n\t\t!isAppend && this._fit(\"after\");\n\t\tif (useRecycle) {\n\t\t\tthis._recycle(isAppend);\n\t\t}\n\n\t\tconst size = this._getEdgeValue(\"end\");\n\n\t\t// recycle after _fit beacause prepend and append are occured simultaneously by scroll.\n\t\tthis._updateEdge();\n\n\t\tisAppend && this._renderer.setContainerSize(size + this._status.loadingSize || 0);\n\t\t!isLayout && this._process(PROCESSING, false);\n\n\t\tconst scrollPos = this._watcher.getScrollPos();\n\t\tconst viewSize = this._renderer.getViewSize();\n\n\t\t/**\n\t\t * This event is fired when layout is successfully arranged through a call to the append(), prepend(), or layout() method.\n\t\t * @ko      . append()  prepend() , layout()        \n\t\t * @event eg.InfiniteGrid#layoutComplete\n\t\t *\n\t\t * @param {Object} param The object of data to be sent to an event <ko>   </ko>\n\t\t * @param {Array} param.target Rearranged card elements<ko>  </ko>\n\t\t * @param {Boolean} param.isAppend Checks whether the append() method is used to add a card element. It returns true even though the layoutComplete event is fired after the layout() method is called. <ko>  append()   . layout()    layoutComplete   'true' .</ko>\n\t\t * @param {Boolean} param.isScroll Checks whether scrolling has occurred after the append(), prepend(), ..., etc method is called\n\t\t * @param {Number} param.scrollPos Current scroll position value relative to the infiniteGrid container element. <ko>infiniteGrid      </ko>\n\t\t * @param {Number} param.orgScrollPos Current position of the scroll <ko>  </ko>\n\t\t * @param {Number} param.size The size of container element <ko>  </ko>\n\t\t * @param {Boolean} param.isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>     true,  API    false .</ko>\n\t\t */\n\t\tthis.trigger(\"layoutComplete\", {\n\t\t\ttarget: items.concat(),\n\t\t\tisAppend,\n\t\t\tisTrusted,\n\t\t\tisScroll: viewSize < this._renderer.getContainerOffset() + size,\n\t\t\tscrollPos,\n\t\t\torgScrollPos: this._watcher.getOrgScrollPos(),\n\t\t\tsize,\n\t\t});\n\t\tif (isLayout) {\n\t\t\treturn;\n\t\t}\n\t\tconst threshold = this.options.threshold;\n\n\t\tif (isAppend && Math.abs(size - viewSize - scrollPos) <= threshold) {\n\t\t\tthis._requestAppend();\n\t\t} else if (!isAppend && scrollPos <= this._getEdgeValue(\"start\") + threshold) {\n\t\t\tthis._fit(\"before\");\n\t\t\tthis._requestPrepend();\n\t\t}\n\t}\n\t_reset() {\n\t\tthis._status = {\n\t\t\tprocessingStatus: IDLE,\n\t\t\tloadingSize: 0,\n\t\t\tstartCursor: -1,\n\t\t\tendCursor: -1,\n\t\t\tstart: null,\n\t\t\tend: null,\n\t\t};\n\t}\n\t/**\n\t * Destroys elements, properties, and events used on a grid layout.\n\t * @ko     ,  \n\t */\n\tdestroy() {\n\t\tthis.off();\n\t\tthis._watcher.destroy();\n\t\tthis._reset();\n\t\tthis._items.clear();\n\t\tthis._renderer.destroy();\n\t}\n}\n\nInfiniteGrid.VERSION = \"#__VERSION__#\";\n\nexport default InfiniteGrid;\n","import {APPEND, PREPEND, ALIGN} from \"../consts\";\nimport {getStyleNames, assignOptions, fill} from \"../utils\";\n\n// ALIGN\nconst {START, CENTER, END, JUSTIFY} = ALIGN;\n\n\n/**\n * @classdesc The GridLayout is a layout that stacks cards with the same width as a stack of bricks. Adjust the width of all images to the same size, find the lowest height column, and insert a new card.\n * @ko GridLayout          .      ,        .            .\n * @class eg.InfiniteGrid.GridLayout\n * @param {Object} [options] The option object of eg.InfiniteGrid.GridLayout module <ko>eg.InfiniteGrid.GridLayout   </ko>\n * @param {String} [options.margin=0] Margin used to create space around items <ko>  </ko>\n * @param {Boolean} [options.horizontal=false] Direction of the scroll movement (false: vertical, true: horizontal) <ko>   (false: , true: )</ko>\n * @param {Boolean} [options.align=START] Align of the position of the items (START, CENTER, END, JUSTIFY) <ko>   (START, CENTER, END, JUSTIFY)</ko>\n * @param {Boolean} [options.itemSize=0] The size of the items. If it is 0, it is calculated as the size of the first item in items. <ko>  .    0,      . </ko>\n * @example\n```\n<script>\nvar ig = new eg.InfiniteGrid(\"#grid\". {\n\thorizontal: true,\n});\n\nig.setLayout(eg.InfiniteGrid.GridLayout, {\n\tmargin: 10,\n\talign: \"start\",\n\titemSize: 200\n});\n\n// or\n\nvar layout = new eg.InfiniteGrid.GridLayout({\n\tmargin: 10,\n\talign: \"center\",\n\titemSize: 200,\n\thorizontal: true,\n});\n\n</script>\n```\n **/\nclass GridLayout {\n\tconstructor(options = {}) {\n\t\tthis.options = assignOptions({\n\t\t\talign: START,\n\t\t\titemSize: 0,\n\t\t}, options);\n\t\tthis._size = 0;\n\t\tthis._columnSize = 0;\n\t\tthis._columnLength = 0;\n\t\tthis._style = getStyleNames(this.options.horizontal);\n\t}\n\tgetPoints(outlines) {\n\t\tconst pos = this.options.horizontal ? \"left\" : \"top\";\n\n\t\treturn outlines.map(outline => outline[pos]);\n\t}\n\tcheckColumn(item) {\n\t\tconst margin = this.options.margin;\n\t\tconst sizeName = this.options.horizontal ? \"height\" : \"width\";\n\t\tconst columnSize = this.options.itemSize || (item && item.size[sizeName]) || 0;\n\n\t\tthis._columnSize = columnSize;\n\t\tif (!columnSize) {\n\t\t\tthis._columnLength = 1;\n\t\t\treturn;\n\t\t}\n\t\tthis._columnLength = Math.max(parseInt((this._size + margin) / (columnSize + margin), 10), 1);\n\t}\n\t_layout(items, outline, isAppend) {\n\t\tconst length = items.length;\n\t\tconst margin = this.options.margin;\n\t\tconst align = this.options.align;\n\t\tconst style = this._style;\n\n\t\tconst size1Name = style.size1;\n\t\tconst size2Name = style.size2;\n\t\tconst pos1Name = style.pos1;\n\t\tconst pos2Name = style.pos2;\n\t\tconst columnSize = this._columnSize;\n\t\tconst columnLength = this._columnLength;\n\n\t\tconst size = this._size;\n\t\tconst viewDist = (size - (columnSize + margin) * columnLength + margin);\n\n\t\tconst pointCaculateName = isAppend ? \"min\" : \"max\";\n\t\tconst startOutline = outline.slice();\n\t\tconst endOutline = outline.slice();\n\t\tconst startIndex = 0;\n\t\tlet endIndex = -1;\n\t\tlet endPos = -1;\n\n\t\tfor (let i = 0; i < length; ++i) {\n\t\t\tconst point = Math[pointCaculateName](...endOutline) || 0;\n\t\t\tlet index = endOutline.indexOf(point);\n\t\t\tconst item = items[isAppend ? i : length - 1 - i];\n\t\t\tconst size1 = item.size[size1Name];\n\t\t\tconst size2 = item.size[size2Name];\n\t\t\tconst pos1 = isAppend ? point : point - margin - size1;\n\t\t\tconst endPos1 = pos1 + size1 + margin;\n\n\t\t\tif (index === -1) {\n\t\t\t\tindex = 0;\n\t\t\t}\n\t\t\tlet pos2 = (columnSize + margin) * index;\n\n\t\t\t// ALIGN\n\t\t\tif (align === CENTER) {\n\t\t\t\tpos2 += viewDist / 2;\n\t\t\t} else if (align === END) {\n\t\t\t\tpos2 += viewDist + columnSize - size2;\n\t\t\t} else if (align === JUSTIFY) {\n\t\t\t\tif (columnLength <= 1) {\n\t\t\t\t\tpos2 += viewDist / 2;\n\t\t\t\t} else {\n\t\t\t\t\tpos2 = (size - columnSize) / (columnLength - 1) * index;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// tetris\n\t\t\titem.rect = {\n\t\t\t\t[pos1Name]: pos1,\n\t\t\t\t[pos2Name]: pos2,\n\t\t\t};\n\t\t\titem.column = index;\n\t\t\tendOutline[index] = isAppend ? endPos1 : pos1;\n\t\t\tif (endIndex === -1) {\n\t\t\t\tendIndex = i;\n\t\t\t\tendPos = endPos1;\n\t\t\t} else if (endPos < endPos1) {\n\t\t\t\tendIndex = i;\n\t\t\t\tendPos = endPos1;\n\t\t\t}\n\t\t}\n\t\tif (!isAppend) {\n\t\t\titems.sort((a, b) => {\n\t\t\t\tconst item1pos1 = a.rect[pos1Name];\n\t\t\t\tconst item1pos2 = a.rect[pos2Name];\n\t\t\t\tconst item2pos1 = b.rect[pos1Name];\n\t\t\t\tconst item2pos2 = b.rect[pos2Name];\n\n\t\t\t\tif (item1pos1 - item2pos1) {\n\t\t\t\t\treturn item1pos1 - item2pos1;\n\t\t\t\t}\n\t\t\t\treturn item1pos2 - item2pos2;\n\t\t\t});\n\t\t\tendIndex = length - 1;\n\t\t}\n\t\t// if append items, startOutline is low, endOutline is high\n\t\t// if prepend items, startOutline is high, endOutline is low\n\t\treturn {\n\t\t\tstart: isAppend ? startOutline : endOutline,\n\t\t\tend: isAppend ? endOutline : startOutline,\n\t\t\tstartIndex,\n\t\t\tendIndex,\n\t\t};\n\t}\n\t_insert(items = [], outline = [], type) {\n\t\tconst clone = items.map(item => Object.assign({}, item));\n\n\t\tlet startOutline = outline;\n\n\t\tif (!this._columnLength) {\n\t\t\tthis.checkColumn(items[0]);\n\t\t}\n\t\tif (outline.length !== this._columnLength) {\n\t\t\tstartOutline = fill(new Array(this._columnLength), outline.length === 0 ? 0 : (Math[type === APPEND ? \"min\" : \"max\"](...outline) || 0));\n\t\t}\n\n\t\tconst result = this._layout(clone, startOutline, type);\n\n\t\treturn {\n\t\t\titems: clone,\n\t\t\toutlines: result,\n\t\t};\n\t}\n\t/**\n\t * Adds items at the bottom of a outline.\n\t * @ko    .\n\t * @method eg.InfiniteGrid.GridLayout#append\n\t * @param {Array} items Array of items to be layouted <ko>  </ko>\n\t * @param {Array} [outline=[]] Array of outline points to be reference points <ko>    </ko>\n\t * @return {Object} Layouted items and outline of start and end <ko>        </ko>\n\t * @example\n\t * layout.prepend(items, [100, 200, 300, 400]);\n\t */\n\tappend(items, outline) {\n\t\treturn this._insert(items, outline, APPEND);\n\t}\n\t/**\n\t * Adds items at the top of a outline.\n\t * @ko    .\n\t * @method eg.InfiniteGrid.GridLayout#prepend\n\t * @param {Array} items Array of items to be layouted <ko>  </ko>\n\t * @param {Array} [outline=[]] Array of outline points to be reference points <ko>    </ko>\n\t * @return {Object} Layouted items and outline of start and end <ko>        </ko>\n\t * @example\n\t * layout.prepend(items, [100, 200, 300, 400]);\n\t */\n\tprepend(items, outline) {\n\t\treturn this._insert(items, outline, PREPEND);\n\t}\n\t/**\n\t * Adds items of groups at the bottom of a outline.\n\t * @ko     .\n\t * @method eg.InfiniteGrid.GridLayout#layout\n\t * @param {Array} groups Array of groups to be layouted <ko>  </ko>\n\t * @param {Array} outline Array of outline points to be reference points <ko>    </ko>\n\t * @return {eg.InfiniteGrid.GridLayout} An instance of a module itself<ko>  </ko>\n\t * @example\n\t * layout.layout(groups, [100, 200, 300, 400]);\n\t */\n\tlayout(groups = [], outline = []) {\n\t\tconst firstItem = (groups.length && groups[0].items.length && groups[0].items[0]) || 0;\n\n\t\tthis.checkColumn(firstItem);\n\n\t\t// if outlines' length and columns' length are now same, re-caculate outlines.\n\t\tlet startOutline;\n\n\t\tif (outline.length !== this._columnLength) {\n\t\t\tconst pos = outline.length === 0 ? 0 : Math.min(...outline);\n\n\t\t\t// re-layout items.\n\t\t\tstartOutline = fill(new Array(this._columnLength), pos);\n\t\t} else {\n\t\t\tstartOutline = outline.slice();\n\t\t}\n\t\tgroups.forEach(group => {\n\t\t\tconst items = group.items;\n\t\t\tconst result = this._layout(items, startOutline, APPEND);\n\n\t\t\tgroup.outlines = result;\n\t\t\tstartOutline = result.end;\n\t\t});\n\n\t\treturn this;\n\t}\n\t/**\n\t * Set the viewport size of the layout.\n\t * @ko    .\n\t * @method eg.InfiniteGrid.GridLayout#setSize\n\t * @param {Number} size The viewport size of container area where items are added to a layout <ko>      </ko>\n\t * @return {eg.InfiniteGrid.GridLayout} An instance of a module itself<ko>  </ko>\n\t * @example\n\t * layout.setSize(800);\n\t */\n\tsetSize(size) {\n\t\tthis._size = size;\n\t\treturn this;\n\t}\n}\n\nexport default GridLayout;\n\n","import {APPEND, PREPEND, DUMMY_POSITION} from \"../consts\";\nimport {getStyleNames, assignOptions, fill} from \"../utils\";\n\n/*\nFrame\n[\n[1, 1, 1, 1, 1],\n[0, 0, 2, 2, 2],\n[0, 0, 2, 2, 2],\n[3, 4, 5, 5, 5],\n]\n*/\nfunction disableFrame(frame, type, x, y, width, height) {\n\tfor (let i = y; i < y + height; ++i) {\n\t\tfor (let j = x; j < x + width; ++j) {\n\t\t\tif (type !== frame[i][j]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tframe[i][j] = 0;\n\t\t}\n\t}\n}\nfunction searchShapeInFrame(frame, type, top, left, width, height) {\n\tconst size = {\n\t\tleft,\n\t\ttop,\n\t\ttype,\n\t\twidth: 1,\n\t\theight: 1,\n\t};\n\n\tfor (let i = left; i < width; ++i) {\n\t\tif (frame[top][i] === type) {\n\t\t\tsize.width = i - left + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\tfor (let i = top; i < height; ++i) {\n\t\tif (frame[i][left] === type) {\n\t\t\tsize.height = i - top + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\t// After finding the shape, it will not find again.\n\tdisableFrame(frame, type, left, top, size.width, size.height);\n\treturn size;\n}\nfunction getShapes(frame) {\n\tconst height = frame.length;\n\tconst width = height ? frame[0].length : 0;\n\tconst shapes = [];\n\n\tfor (let i = 0; i < height; ++i) {\n\t\tfor (let j = 0; j < width; ++j) {\n\t\t\tconst type = frame[i][j];\n\n\t\t\tif (!type) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// Separate shapes with other numbers.\n\t\t\tshapes.push(searchShapeInFrame(frame, type, i, j, width, height));\n\t\t}\n\t}\n\tshapes.sort((a, b) => (a.type < b.type ? -1 : 1));\n\treturn {\n\t\tshapes,\n\t\twidth,\n\t\theight,\n\t};\n}\n/**\n * @classdesc FrameLayout is a layout that allows you to place cards in a given frame. It is a layout that corresponds to a level intermediate between the placement of the image directly by the designer and the layout using the algorithm.\n * @ko FrameLayout      .             .\n * @class eg.InfiniteGrid.FrameLayout\n * @param {Object} [options] The option object of eg.InfiniteGrid.FrameLayout module <ko>eg.InfiniteGrid.FrameLayout   </ko>\n * @param {String} [options.margin=0] Margin used to create space around items <ko>  </ko>\n * @param {Boolean} [options.horizontal=false] Direction of the scroll movement (false: vertical, true: horizontal) <ko>   (false: , true: )</ko>\n * @param {Boolean} [options.itemSize=0] The size of the items. If it is 0, it is calculated as the size of the first item in items. <ko>  .    0,      . </ko>\n * @param {Boolean} [options.frame=[]] The size of the items. If it is 0, it is calculated as the size of the first item in items. <ko>  .    0,      . </ko>\n * @param {Boolean} [options.frameFill=true] Make sure that the frame can be attached after the previous frame. <ko>          . </ko>\n * @example\n```\n<script>\nvar ig = new eg.InfiniteGrid(\"#grid\". {\n\thorizontal: true,\n});\n\nig.setLayout(eg.InfiniteGrid.FrameLayout, {\n\tmargin: 10,\n\titemSize: 200,\n\tframe: [\n\t\t[1, 1, 1, 1, 1],\n\t\t[0, 0, 2, 2, 2],\n\t\t[0, 0, 2, 2, 2],\n\t\t[3, 4, 5, 5, 5],\n\t],\n});\n\n// or\n\nvar layout = new eg.InfiniteGrid.FrameLayout({\n\tmargin: 10,\n\titemSize: 200,\n\thorizontal: true,\n\tframe: [\n\t\t[1, 1, 1, 1, 1],\n\t\t[0, 0, 2, 2, 2],\n\t\t[0, 0, 2, 2, 2],\n\t\t[3, 4, 5, 5, 5],\n\t],\n});\n\n</script>\n```\n **/\nclass FrameLayout {\n\tconstructor(options = {}) {\n\t\tthis.options = assignOptions({\n\t\t\titemSize: 0,\n\t\t\tframe: [],\n\t\t\tframeFill: true,\n\t\t}, options);\n\t\tconst frame = this.options.frame.map(row => row.slice());\n\t\t// divide frame into shapes.\n\t\tconst shapes = getShapes(frame);\n\n\t\tthis._itemSize = this.options.itemSize || 0;\n\t\tthis._shapes = shapes;\n\t\tthis._size = 0;\n\t\tthis._style = getStyleNames(this.options.horizontal);\n\t}\n\t_getItemSize() {\n\t\tthis._checkItemSize();\n\n\t\treturn this._itemSize;\n\t}\n\t_checkItemSize() {\n\t\tif (this.options.itemSize) {\n\t\t\tthis._itemSize = this.options.itemSize;\n\t\t\treturn;\n\t\t}\n\t\tconst style = this._style;\n\t\tconst size = style.size2;\n\t\tconst margin = this.options.margin;\n\n\t\t// if itemSize is not in options, caculate itemSize from size.\n\t\tthis._itemSize = (this._size + margin) / this._shapes[size] - margin;\n\t}\n\t_layout(items, outline = [], isAppend) {\n\t\tconst length = items.length;\n\t\tconst style = this._style;\n\t\tconst {margin, frameFill} = this.options;\n\t\tconst size1Name = style.size1;\n\t\tconst size2Name = style.size2;\n\t\tconst pos1Name = style.pos1;\n\t\tconst pos2Name = style.pos2;\n\t\tconst itemSize = this._getItemSize();\n\t\tconst isItemObject = typeof itemSize === \"object\";\n\t\tconst itemSize2 = isItemObject ? itemSize[size2Name] : itemSize;\n\t\tconst itemSize1 = isItemObject ? itemSize[size1Name] : itemSize;\n\t\tconst shapesSize = this._shapes[size2Name];\n\t\tconst shapes = this._shapes.shapes;\n\t\tconst shapesLength = shapes.length;\n\t\tconst startOutline = fill(new Array(shapesSize), DUMMY_POSITION);\n\t\tconst endOutline = fill(new Array(shapesSize), DUMMY_POSITION);\n\t\tlet dist = 0;\n\t\tlet end = 0;\n\t\tlet startIndex = -1;\n\t\tlet endIndex = -1;\n\t\tlet minPos = -1;\n\t\tlet maxPos = -1;\n\n\t\tif (!shapesLength) {\n\t\t\treturn {start: outline, end: outline, startIndex, endIndex};\n\t\t}\n\t\tfor (let i = 0; i < length; i += shapesLength) {\n\t\t\tfor (let j = 0; j < shapesLength && i + j < length; ++j) {\n\t\t\t\tconst item = items[i + j];\n\t\t\t\tconst shape = shapes[j];\n\t\t\t\tconst shapePos1 = shape[pos1Name];\n\t\t\t\tconst shapePos2 = shape[pos2Name];\n\t\t\t\tconst shapeSize1 = shape[size1Name];\n\t\t\t\tconst shapeSize2 = shape[size2Name];\n\t\t\t\tconst pos1 = end - dist + shapePos1 * (itemSize1 + margin);\n\t\t\t\tconst pos2 = shapePos2 * (itemSize2 + margin);\n\t\t\t\tconst size1 = shapeSize1 * (itemSize1 + margin) - margin;\n\t\t\t\tconst size2 = shapeSize2 * (itemSize2 + margin) - margin;\n\n\t\t\t\tfor (let k = shapePos2; k < shapePos2 + shapeSize2 && k < shapesSize; ++k) {\n\t\t\t\t\tif (startOutline[k] === DUMMY_POSITION) {\n\t\t\t\t\t\tstartOutline[k] = pos1;\n\t\t\t\t\t}\n\t\t\t\t\tif (startIndex === -1) {\n\t\t\t\t\t\tminPos = pos1;\n\t\t\t\t\t\tstartIndex = i + j;\n\t\t\t\t\t\tmaxPos = pos1 + size1 + margin;\n\t\t\t\t\t\tendIndex = i + j;\n\t\t\t\t\t}\n\t\t\t\t\tif (minPos > pos1) {\n\t\t\t\t\t\tminPos = pos1;\n\t\t\t\t\t\tstartIndex = i + j;\n\t\t\t\t\t}\n\t\t\t\t\tif (maxPos < pos1 + size1 + margin) {\n\t\t\t\t\t\tmaxPos = pos1 + size1 + margin;\n\t\t\t\t\t\tendIndex = i + j;\n\t\t\t\t\t}\n\t\t\t\t\tstartOutline[k] = Math.min(startOutline[k], pos1);\n\t\t\t\t\tendOutline[k] = Math.max(endOutline[k], pos1 + size1 + margin);\n\t\t\t\t}\n\t\t\t\titem.rect = {\n\t\t\t\t\t[pos1Name]: pos1,\n\t\t\t\t\t[pos2Name]: pos2,\n\t\t\t\t\t[size1Name]: size1,\n\t\t\t\t\t[size2Name]: size2,\n\t\t\t\t};\n\t\t\t}\n\t\t\tend = Math.max(...endOutline);\n\t\t\t// check dist once\n\t\t\tif (i !== 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// find & fill empty block\n\t\t\tif (!frameFill) {\n\t\t\t\tdist = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdist = end;\n\n\t\t\tfor (let j = 0; j < shapesSize; ++j) {\n\t\t\t\tif (startOutline[j] === DUMMY_POSITION) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// the dist between frame's end outline and next frame's start outline\n\t\t\t\t// expect that next frame's start outline is startOutline[j] + end\n\t\t\t\tdist = Math.min(startOutline[j] + end - endOutline[j], dist);\n\t\t\t}\n\t\t}\n\t\tfor (let i = 0; i < shapesSize; ++i) {\n\t\t\tif (startOutline[i] !== DUMMY_POSITION) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstartOutline[i] = Math.max(...startOutline);\n\t\t\tendOutline[i] = startOutline[i];\n\t\t}\n\t\t// The target outline is start outline when type is APPENDING\n\t\tconst targetOutline = isAppend ? startOutline : endOutline;\n\t\tconst prevOutlineEnd = outline.length === 0 ? 0 : Math[isAppend ? \"max\" : \"min\"](...outline);\n\t\tlet prevOutlineDist = isAppend ? 0 : end;\n\n\t\tif (frameFill && outline.length === shapesSize) {\n\t\t\tprevOutlineDist = -DUMMY_POSITION;\n\t\t\tfor (let i = 0; i < shapesSize; ++i) {\n\t\t\t\tif (startOutline[i] === endOutline[i]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// if appending type is PREPEND, subtract dist from appending group's height.\n\n\t\t\t\tprevOutlineDist = Math.min(targetOutline[i] + prevOutlineEnd - outline[i], prevOutlineDist);\n\t\t\t}\n\t\t}\n\t\tfor (let i = 0; i < shapesSize; ++i) {\n\t\t\tstartOutline[i] += prevOutlineEnd - prevOutlineDist;\n\t\t\tendOutline[i] += prevOutlineEnd - prevOutlineDist;\n\t\t}\n\t\titems.forEach(item => {\n\t\t\titem.rect[pos1Name] += prevOutlineEnd - prevOutlineDist;\n\t\t});\n\t\treturn {\n\t\t\tstart: startOutline,\n\t\t\tend: endOutline,\n\t\t\tstartIndex,\n\t\t\tendIndex,\n\t\t};\n\t}\n\t_insert(items, outline, type) {\n\t\t// this only needs the size of the item.\n\t\tconst clone = items.map(item => Object.assign({}, item));\n\n\t\treturn {\n\t\t\titems: clone,\n\t\t\toutlines: this._layout(clone, outline, type),\n\t\t};\n\t}\n\t/**\n\t * Adds items of groups at the bottom of a outline.\n\t * @ko     .\n\t * @method eg.InfiniteGrid.FrameLayout#layout\n\t * @param {Array} groups Array of groups to be layouted <ko>  </ko>\n\t * @param {Array} outline Array of outline points to be reference points <ko>    </ko>\n\t * @return {eg.InfiniteGrid.FrameLayout} An instance of a module itself<ko>  </ko>\n\t * @example\n\t * layout.layout(groups, [100, 200, 300, 400]);\n\t */\n\tlayout(groups, outlines) {\n\t\tconst length = groups.length;\n\t\tlet point = outlines;\n\n\t\tfor (let i = 0; i < length; ++i) {\n\t\t\tconst group = groups[i];\n\n\t\t\tpoint = this._layout(group.items, point, APPEND);\n\t\t\tgroup.outlines = point;\n\t\t\tpoint = point.end;\n\t\t}\n\t\treturn this;\n\t}\n\t/**\n\t * Set the viewport size of the layout.\n\t * @ko    .\n\t * @method eg.InfiniteGrid.FrameLayout#setSize\n\t * @param {Number} size The viewport size of container area where items are added to a layout <ko>      </ko>\n\t * @return {eg.InfiniteGrid.FrameLayout} An instance of a module itself<ko>  </ko>\n\t * @example\n\t * layout.setSize(800);\n\t */\n\tsetSize(size) {\n\t\tthis._size = size;\n\t\treturn this;\n\t}\n\t/**\n\t * Adds items at the bottom of a outline.\n\t * @ko    .\n\t * @method eg.InfiniteGrid.FrameLayout#append\n\t * @param {Array} items Array of items to be layouted <ko>  </ko>\n\t * @param {Array} [outline=[]] Array of outline points to be reference points <ko>    </ko>\n\t * @return {Object} Layouted items and outline of start and end <ko>        </ko>\n\t * @example\n\t * layout.prepend(items, [100]);\n\t */\n\tappend(items, outline) {\n\t\treturn this._insert(items, outline, APPEND);\n\t}\n\t/**\n\t * Adds items at the top of a outline.\n\t * @ko    .\n\t * @method eg.InfiniteGrid.FrameLayout#prepend\n\t * @param {Array} items Array of items to be layouted <ko>  </ko>\n\t * @param {Array} [outline=[]] Array of outline points to be reference points <ko>    </ko>\n\t * @return {Object} Layouted items and outline of start and end <ko>        </ko>\n\t * @example\n\t * layout.prepend(items, [100]);\n\t */\n\tprepend(items, outline) {\n\t\treturn this._insert(items, outline, PREPEND);\n\t}\n}\n\nexport default FrameLayout;\n","import FrameLayout from \"./FrameLayout\";\nimport {fill} from \"../utils\";\n\nfunction makeShapeOutline(outline, itemSize, columnLength, isAppend) {\n\tconst point = Math[isAppend ? \"min\" : \"max\"](...outline) || 0;\n\n\tif (outline.length !== columnLength) {\n\t\treturn fill(new Array(columnLength), 0);\n\t}\n\treturn outline.map(l => parseInt((l - point) / itemSize, 10));\n}\nfunction getColumn(item) {\n\tif (item.column) {\n\t\treturn item.column;\n\t}\n\tlet column = 0;\n\n\tif (item.el) {\n\t\tconst dataset = item.el.dataset;\n\n\t\tif (dataset) {\n\t\t\tcolumn = dataset.column || 1;\n\t\t} else {\n\t\t\tcolumn = item.el.getAttribute(\"column\") || 1;\n\t\t}\n\t} else {\n\t\tcolumn = 1;\n\t}\n\titem.column = column;\n\treturn column;\n}\n\n/**\n * @classdesc SquareLayout is a layout that places all cards like squares on a checkerboard, and important cards are n times larger. The main card can be enlarged, and then a small card can be placed to naturally show the relationship of the card.\n * @ko SquareLayout         N   .    ,           .\n * @class eg.InfiniteGrid.SquareLayout\n * @extends eg.InfiniteGrid.FrameLayout\n * @param {Object} [options] The option object of eg.InfiniteGrid.SquareLayout module <ko>eg.InfiniteGrid.SquareLayout   </ko>\n * @param {String} [options.margin=0] Margin used to create space around items <ko>  </ko>\n * @param {Boolean} [options.horizontal=false] Direction of the scroll movement (false: vertical, true: horizontal) <ko>   (false: , true: )</ko>\n * @param {Boolean} [options.itemSize=0] The size of the items. If it is 0, it is calculated as the size of the first item in items. <ko>  .    0,      . </ko>\n * @example\n```\n<script>\nvar ig = new eg.InfiniteGrid(\"#grid\". {\n\thorizontal: true,\n});\n\nig.setLayout(eg.InfiniteGrid.SquareLayout, {\n\tmargin: 10,\n\titemSize: 200,\n});\n\n// or\n\nvar layout = new eg.InfiniteGrid.SquareLayout({\n\tmargin: 10,\n\titemSize: 200,\n\thorizontal: true,\n});\n\n\nvar item1 = '<div data-column=\"2\"></div>';\nvar item2 = \"<div></div>\"\nlayout.append([item1, item2]);\n</script>\n```\n **/\nclass SquareLayout extends FrameLayout {\n\t_checkItemSize() {\n\t\tconst column = this.options.column;\n\n\t\tif (!column) {\n\t\t\tsuper._checkItemSize();\n\t\t\treturn;\n\t\t}\n\t\tconst margin = this.options.margin;\n\n\t\t// if itemSize is not in options, caculate itemSize from size.\n\t\tthis._itemSize = (this._size + margin) / column - margin;\n\t}\n\t_layout(items, outline = [], isAppend) {\n\t\tconst itemSize = this._getItemSize();\n\t\tconst margin = this.options.margin;\n\t\tconst columnLength = this.options.column ||\n\t\t\t\tparseInt((this._size + margin) / (itemSize + margin), 10) || 1;\n\t\tconst length = items.length;\n\t\tconst endOutline = makeShapeOutline(outline, itemSize, columnLength, isAppend);\n\t\tconst pointCaculateName = isAppend ? \"min\" : \"max\";\n\t\tconst shapes = [];\n\t\tconst sign = isAppend ? 1 : -1;\n\t\tconst style = this._style;\n\t\tconst pos1Name = style.pos1;\n\t\tconst pos2Name = style.pos2;\n\n\t\tfor (let i = 0; i < length; ++i) {\n\t\t\tconst point = Math[pointCaculateName](...endOutline);\n\t\t\tlet index = endOutline[isAppend ? \"indexOf\" : \"lastIndexOf\"](point);\n\t\t\tconst item = items[i];\n\t\t\tconst columnWidth = item.columnWidth;\n\t\t\tconst column = (columnWidth && columnWidth[0] === columnLength &&\n\t\t\t\t\tcolumnWidth[1]) || getColumn(item);\n\t\t\tlet columnCount = 1;\n\n\t\t\tif (column > 1) {\n\t\t\t\tfor (let j = 1; j < column &&\n\t\t\t\t\t\t((isAppend && index + j < columnLength) || (!isAppend && index - j >= 0)); ++j) {\n\t\t\t\t\tif ((isAppend && endOutline[index + sign * j] <= point) ||\n\t\t\t\t\t\t(!isAppend && endOutline[index + sign * j] >= point)) {\n\t\t\t\t\t\t++columnCount;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!isAppend) {\n\t\t\t\t\tindex -= columnCount - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\titem.columnWidth = [columnLength, columnCount];\n\t\t\tshapes.push({\n\t\t\t\twidth: columnCount,\n\t\t\t\theight: columnCount,\n\t\t\t\t[pos1Name]: point - (!isAppend ? columnCount : 0),\n\t\t\t\t[pos2Name]: index,\n\t\t\t\tindex: i,\n\t\t\t});\n\t\t\tfor (let j = 0; j < columnCount; ++j) {\n\t\t\t\tendOutline[index + j] = point + sign * columnCount;\n\t\t\t}\n\t\t}\n\t\tthis._shapes = {\n\t\t\tshapes,\n\t\t\t[style.size2]: columnLength,\n\t\t};\n\n\t\tconst result = super._layout(items, outline, isAppend);\n\n\t\tif (!isAppend) {\n\t\t\tconst lastItem = items[items.length - 1];\n\n\t\t\tshapes.sort((shape1, shape2) => {\n\t\t\t\tconst item1pos1 = shape1[pos1Name];\n\t\t\t\tconst item1pos2 = shape1[pos2Name];\n\t\t\t\tconst item2pos1 = shape2[pos1Name];\n\t\t\t\tconst item2pos2 = shape2[pos2Name];\n\n\t\t\t\tif (item1pos1 - item2pos1) {\n\t\t\t\t\treturn item1pos1 - item2pos1;\n\t\t\t\t}\n\t\t\t\treturn item1pos2 - item2pos2;\n\t\t\t});\n\t\t\titems.sort((a, b) => {\n\t\t\t\tconst item1pos1 = a.rect[pos1Name];\n\t\t\t\tconst item1pos2 = a.rect[pos2Name];\n\t\t\t\tconst item2pos1 = b.rect[pos1Name];\n\t\t\t\tconst item2pos2 = b.rect[pos2Name];\n\n\t\t\t\tif (item1pos1 - item2pos1) {\n\t\t\t\t\treturn item1pos1 - item2pos1;\n\t\t\t\t}\n\t\t\t\treturn item1pos2 - item2pos2;\n\t\t\t});\n\t\t\tresult.startIndex = 0;\n\t\t\tresult.endIndex = items.indexOf(lastItem);\n\t\t}\n\t\treturn result;\n\t}\n}\n\nexport default SquareLayout;\n","import BoxModel from \"./lib/BoxModel.js\";\nimport {APPEND, PREPEND} from \"../consts\";\nimport {getStyleNames, assignOptions, toZeroArray} from \"../utils\";\n\n\nfunction getCost(originLength, length) {\n\tlet cost = originLength / length;\n\n\tif (cost < 1) {\n\t\tcost = 1 / cost;\n\t}\n\n\treturn cost - 1;\n}\nfunction fitArea(item, bestFitArea, itemFitSize, containerFitSize, layoutVertical) {\n\titem.setHeight(itemFitSize.height);\n\titem.setWidth(itemFitSize.width);\n\tbestFitArea.setHeight(containerFitSize.height);\n\tbestFitArea.setWidth(containerFitSize.width);\n\n\tif (layoutVertical) {\n\t\titem.setTop(bestFitArea.getTop() + bestFitArea.getHeight());\n\t\titem.setLeft(bestFitArea.getLeft());\n\t} else {\n\t\titem.setLeft(bestFitArea.getLeft() + bestFitArea.getWidth());\n\t\titem.setTop(bestFitArea.getTop());\n\t}\n}\n\n/**\n * @classdesc The PackingLayout is a layout that shows the important cards bigger without sacrificing the weight of the cards. Rows and columns are separated so that cards are dynamically placed within the horizontal and vertical space rather than arranged in an orderly fashion.\n * @ko PackingLayout              .              .\n * @class eg.InfiniteGrid.PackingLayout\n * @param {Object} [options] The option object of eg.InfiniteGrid.PackingLayout module <ko>eg.InfiniteGrid.PackingLayout   </ko>\n * @param {String} [options.margin=0] Margin used to create space around items <ko>  </ko>\n * @param {Boolean} [options.horizontal=false] Direction of the scroll movement (false: vertical, true: horizontal) <ko>   (false: , true: )</ko>\n * @param {Boolean} [options.aspectRatio=1] The aspect ratio of the group <ko>     </ko>\n * @param {Boolean} [options.sizeWeight=1] The size weight when placing an image <ko>      </ko>\n * @param {Boolean} [options.ratioWeight=1] The ratio weight when placing an image <ko>      </ko>\n * @example\n```\n<script>\nvar ig = new eg.InfiniteGrid(\"#grid\". {\n\thorizontal: true,\n});\n\nig.setLayout(eg.InfiniteGrid.PackingLayout, {\n\tmargin: 10,\n\taspectRatio: 1,\n\tsizeWeight: 1,\n\tratioWeight: 2,\n});\n\n// or\n\nvar layout = new eg.InfiniteGrid.PackingLayout({\n\thorizontal: true,\n\tmargin: 10,\n\taspectRatio: 1,\n\tsizeWeight: 1,\n\tratioWeight: 2,\n});\n\n</script>\n```\n **/\nclass PackingLayout {\n\tconstructor(options = {}) {\n\t\tthis.options = assignOptions({\n\t\t\taspectRatio: 1,\n\t\t\tsizeWeight: 1,\n\t\t\tratioWeight: 1,\n\t\t}, options);\n\t\tthis._size = 0;\n\t\tthis._style = getStyleNames(this.options.horizontal);\n\t}\n\t_findBestFitArea(container, item) {\n\t\tif (container.getRatio() === 0) { //     \n\t\t\tcontainer.setOriginWidth(item.getWidth());\n\t\t\tcontainer.setOriginHeight(item.getHeight());\n\t\t\tcontainer.setWidth(item.getWidth());\n\t\t\tcontainer.setHeight(item.getHeight());\n\t\t\treturn;\n\t\t}\n\n\t\tlet bestFitArea = null;\n\t\tlet minCost = 10000000;\n\t\tlet layoutVertical = false;\n\t\tconst itemFitSize = {\n\t\t\twidth: 0,\n\t\t\theight: 0,\n\t\t};\n\t\tconst containerFitSize = {\n\t\t\twidth: 0,\n\t\t\theight: 0,\n\t\t};\n\t\tconst {sizeWeight, ratioWeight} = this.options;\n\n\t\tcontainer.innerItem().forEach(v => {\n\t\t\tconst containerSizeCost = getCost(v.getOriginSize(), v.getSize()) * sizeWeight;\n\t\t\tconst containerRatioCost = getCost(v.getOriginRatio(), v.getRatio()) * ratioWeight;\n\t\t\tlet cost;\n\n\t\t\tfor (let i = 0; i < 2; ++i) {\n\t\t\t\tlet itemWidth;\n\t\t\t\tlet itemHeight;\n\t\t\t\tlet containerWidth;\n\t\t\t\tlet containerHeight;\n\n\t\t\t\tif (i === 0) {\n\t\t\t\t\t//   \n\t\t\t\t\titemWidth = v.getWidth();\n\t\t\t\t\titemHeight = v.getHeight() * (item.getHeight() / (v.getOriginHeight() + item.getHeight()));\n\t\t\t\t\tcontainerWidth = v.getWidth();\n\t\t\t\t\tcontainerHeight = v.getHeight() - itemHeight;\n\t\t\t\t} else {\n\t\t\t\t\t//   \n\t\t\t\t\titemHeight = v.getHeight();\n\t\t\t\t\titemWidth = v.getWidth() * (item.getWidth() / (v.getOriginWidth() + item.getWidth()));\n\t\t\t\t\tcontainerHeight = v.getHeight();\n\t\t\t\t\tcontainerWidth = v.getWidth() - itemWidth;\n\t\t\t\t}\n\n\t\t\t\tconst itemSize = itemWidth * itemHeight;\n\t\t\t\tconst itemRatio = itemWidth / itemHeight;\n\t\t\t\tconst containerSize = containerWidth * containerHeight;\n\t\t\t\tconst containerRatio = containerHeight / containerHeight;\n\n\t\t\t\tcost = getCost(item.getSize(), itemSize) * sizeWeight;\n\t\t\t\tcost += getCost(item.getRatio(), itemRatio) * ratioWeight;\n\t\t\t\tcost += getCost(v.getOriginSize(), containerSize) * sizeWeight - containerSizeCost;\n\t\t\t\tcost += getCost(v.getOriginRatio(), containerRatio) * ratioWeight - containerRatioCost;\n\n\t\t\t\tif (cost === Math.min(cost, minCost)) {\n\t\t\t\t\tminCost = cost;\n\t\t\t\t\tbestFitArea = v;\n\t\t\t\t\tlayoutVertical = (i === 0);\n\t\t\t\t\titemFitSize.width = itemWidth;\n\t\t\t\t\titemFitSize.height = itemHeight;\n\t\t\t\t\tcontainerFitSize.width = containerWidth;\n\t\t\t\t\tcontainerFitSize.height = containerHeight;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tfitArea(item, bestFitArea, itemFitSize, containerFitSize, layoutVertical);\n\t}\n\t_layout(items, outline = [], isAppend) {\n\t\tconst style = this._style;\n\t\tconst isHorizontal = this.options.horizontal;\n\t\tconst aspectRatio = this.options.aspectRatio;\n\t\tconst margin = this.options.margin;\n\t\tconst pos1Name = style.pos1;\n\t\tconst size1Name = style.size1;\n\t\tconst containerWidth = this._size * (isHorizontal ? aspectRatio : 1);\n\t\tconst containerHeight = this._size / (isHorizontal ? 1 : aspectRatio);\n\t\tconst containerSize1 = isHorizontal ? containerWidth : containerHeight;\n\t\tconst prevOutline = toZeroArray(outline);\n\t\tconst start = isAppend ? Math.max(...prevOutline) :\n\t\t\tMath.min(...prevOutline) - containerSize1 - margin;\n\t\tconst end = start + containerSize1 + margin;\n\t\tconst container = new BoxModel({});\n\n\t\tlet startIndex = -1;\n\t\tlet endIndex = -1;\n\t\tlet startPos = -1;\n\t\tlet endPos = -1;\n\n\t\titems.forEach(item => {\n\t\t\tconst model = new BoxModel({\n\t\t\t\toriginWidth: item.orgSize.width,\n\t\t\t\toriginHeight: item.orgSize.height,\n\t\t\t\twidth: item.orgSize.width,\n\t\t\t\theight: item.orgSize.height,\n\t\t\t});\n\n\t\t\tthis._findBestFitArea(container, model);\n\t\t\tcontainer.pushItem(model);\n\t\t\tcontainer.scaleTo(containerWidth + margin, containerHeight + margin);\n\t\t});\n\t\titems.forEach((item, i) => {\n\t\t\tconst boxItem = container.innerItem()[i];\n\t\t\t// console.log(\"boxItem\", boxItem, boxItem instanceof BoxModel);\n\t\t\tconst width = boxItem.getWidth();\n\t\t\tconst height = boxItem.getHeight();\n\t\t\tconst top = boxItem.getTop();\n\t\t\tconst left = boxItem.getLeft();\n\n\t\t\titem.rect = {top, left, width: width - margin, height: height - margin};\n\t\t\titem.rect[pos1Name] += start;\n\n\t\t\tif (startIndex === -1) {\n\t\t\t\tstartIndex = i;\n\t\t\t\tendIndex = i;\n\t\t\t\tstartPos = item.rect[pos1Name];\n\t\t\t\tendPos = startPos;\n\t\t\t}\n\t\t\tif (startPos > item.rect[pos1Name]) {\n\t\t\t\tstartPos = item.rect[pos1Name];\n\t\t\t\tstartIndex = i;\n\t\t\t}\n\t\t\tif (endPos < item.rect[pos1Name] + item.rect[size1Name] + margin) {\n\t\t\t\tendPos = item.rect[pos1Name] + item.rect[size1Name] + margin;\n\t\t\t\tendIndex = i;\n\t\t\t}\n\t\t});\n\n\t\treturn {\n\t\t\tstart: [start],\n\t\t\tend: [end],\n\t\t\tstartIndex,\n\t\t\tendIndex,\n\t\t};\n\t}\n\t_insert(items = [], outline = [], type) {\n\t\t// this only needs the size of the item.\n\t\tconst clone = items.map(item => Object.assign({}, item));\n\n\t\treturn {\n\t\t\titems: clone,\n\t\t\toutlines: this._layout(clone, outline, type),\n\t\t};\n\t}\n\t/**\n\t * Adds items at the bottom of a outline.\n\t * @ko    .\n\t * @method eg.InfiniteGrid.PackingLayout#append\n\t * @param {Array} items Array of items to be layouted <ko>  </ko>\n\t * @param {Array} [outline=[]] Array of outline points to be reference points <ko>    </ko>\n\t * @return {Object} Layouted items and outline of start and end <ko>        </ko>\n\t * @example\n\t * layout.prepend(items, [100]);\n\t */\n\tappend(items, outline) {\n\t\treturn this._insert(items, outline, APPEND);\n\t}\n\t/**\n\t * Adds items at the top of a outline.\n\t * @ko    .\n\t * @method eg.InfiniteGrid.PackingLayout#prepend\n\t * @param {Array} items Array of items to be layouted <ko>  </ko>\n\t * @param {Array} [outline=[]] Array of outline points to be reference points <ko>    </ko>\n\t * @return {Object} Layouted items and outline of start and end <ko>        </ko>\n\t * @example\n\t * layout.prepend(items, [100]);\n\t */\n\tprepend(items, outline) {\n\t\treturn this._insert(items, outline, PREPEND);\n\t}\n\t/**\n\t * Adds items of groups at the bottom of a outline.\n\t * @ko     .\n\t * @method eg.InfiniteGrid.PackingLayout#layout\n\t * @param {Array} groups Array of groups to be layouted <ko>  </ko>\n\t * @param {Array} outline Array of outline points to be reference points <ko>    </ko>\n\t * @return {eg.InfiniteGrid.PackingLayout} An instance of a module itself<ko>  </ko>\n\t * @example\n\t * layout.layout(groups, [100, 200, 300, 400]);\n\t */\n\tlayout(groups = [], outline = []) {\n\t\tconst length = groups.length;\n\t\tlet point = outline;\n\n\t\tfor (let i = 0; i < length; ++i) {\n\t\t\tconst group = groups[i];\n\n\t\t\tpoint = this._layout(group.items, point, APPEND);\n\t\t\tgroup.outlines = point;\n\t\t\tpoint = point.end;\n\t\t}\n\t\treturn this;\n\t}\n\t/**\n\t * Set the viewport size of the layout.\n\t * @ko    .\n\t * @method eg.InfiniteGrid.PackingLayout#setSize\n\t * @param {Number} size The viewport size of container area where items are added to a layout <ko>      </ko>\n\t * @return {eg.InfiniteGrid.PackingLayout} An instance of a module itself<ko>  </ko>\n\t * @example\n\t * layout.setSize(800);\n\t */\n\tsetSize(size) {\n\t\tthis._size = size;\n\t\treturn this;\n\t}\n}\n\nexport default PackingLayout;\n","import dijkstra from \"./lib/dijkstra\";\nimport {APPEND, PREPEND} from \"../consts\";\nimport {getStyleNames, assignOptions} from \"../utils\";\n\n/**\n * @classdesc 'justified' is a printing term with the meaning that 'it fits in one row wide'. JustifiedLayout is a layout that the card is filled up on the basis of a line given a size.\n * @ko 'justified' '1    '    .           .\n * @class eg.InfiniteGrid.JustifiedLayout\n * @param {Object} [options] The option object of eg.InfiniteGrid.JustifiedLayout module <ko>eg.InfiniteGrid.JustifiedLayout   </ko>\n * @param {String} [options.margin=0] Margin used to create space around items <ko>  </ko>\n * @param {Boolean} [options.horizontal=false] Direction of the scroll movement (false: vertical, true: horizontal) <ko>   (false: , true: )</ko>\n * @param {Number} [options.minSize=0] Minimum size of item to be resized <ko>     </ko>\n * @param {Number} [options.maxSize=0] Maximum size of item to be resized <ko>     </ko>\n * @param {Array|Number} [options.column=[1, 8]] The number of items in a line <ko>      </ko>\n * @example\n```\n<script>\nvar ig = new eg.InfiniteGrid(\"#grid\". {\n\thorizontal: true,\n});\n\nig.setLayout(eg.InfiniteGrid.JustifiedLayout, {\n\tmargin: 10,\n\tminSize: 100,\n\tmaxSize: 300,\n});\n\n// or\n\nvar layout = new eg.InfiniteGrid.JustifiedLayout({\n\tmargin: 10,\n\tminSize: 100,\n\tmaxSize: 300,\n\tcolumn: 5,\n\thorizontal: true,\n});\n\n</script>\n```\n **/\nclass JustifiedLayout {\n\tconstructor(options = {}) {\n\t\tthis.options = assignOptions({\n\t\t\tminSize: 0,\n\t\t\tmaxSize: 0,\n\t\t\tcolumn: [1, 8],\n\t\t}, options);\n\n\t\tthis._style = getStyleNames(this.options.horizontal);\n\t\tthis._size = 0;\n\t}\n\t_layout(items, outline, isAppend) {\n\t\tconst style = this._style;\n\t\tconst size1Name = style.size1;\n\t\tconst size2Name = style.size2;\n\t\tconst startIndex = 0;\n\t\tconst endIndex = items.length;\n\t\tlet column = this.options.column;\n\n\t\tif (typeof column !== \"object\") {\n\t\t\tcolumn = [column, column];\n\t\t}\n\n\t\tconst graph = _start => {\n\t\t\tconst results = {};\n\t\t\tconst start = +_start.replace(/[^0-9]/g, \"\");\n\t\t\tconst length = endIndex + 1;\n\n\t\t\tfor (let i = Math.min(start + column[0], length - 1); i < length; ++i) {\n\t\t\t\tif (i - start > column[1]) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlet cost = this._getCost(items, start, i, size1Name, size2Name);\n\n\t\t\t\tif (cost < 0 && i === length - 1) {\n\t\t\t\t\tcost = 0;\n\t\t\t\t}\n\t\t\t\tif (cost !== null) {\n\t\t\t\t\tresults[`node${i}`] = Math.pow(cost, 2);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\t\t// shortest path for items' total height.\n\t\tconst path = dijkstra.find_path(graph, `node${startIndex}`, `node${endIndex}`);\n\n\t\treturn this._setStyle(items, path, outline, isAppend);\n\t}\n\t_getSize(items, size1Name, size2Name) {\n\t\tconst margin = this.options.margin;\n\t\tconst size = items.reduce((sum, item) => sum +\n\t\t\t\t\t\t\t(item.size[size2Name]) / item.size[size1Name], 0);\n\n\t\treturn (this._size - margin * (items.length - 1)) / size;\n\t}\n\t_getCost(items, i, j, size1Name, size2Name) {\n\t\tconst size = this._getSize(items.slice(i, j), size1Name, size2Name);\n\t\tconst min = this.options.minSize || 0;\n\t\tconst max = this.options.maxSize || Infinity;\n\n\t\tif (isFinite(max)) {\n\t\t\t// if this size is not in range, the cost increases sharply.\n\t\t\tif (size < min) {\n\t\t\t\treturn Math.pow(size - min, 2) + Math.pow(max, 2);\n\t\t\t} else if (size > max) {\n\t\t\t\treturn Math.pow(size - max, 2) + Math.pow(max, 2);\n\t\t\t} else {\n\t\t\t\t// if this size in range, the cost is negative or low.\n\t\t\t\treturn Math.min(size - max, min - size);\n\t\t\t}\n\t\t}\n\t\t// if max is infinite type, caculate cost only with \"min\".\n\t\tif (size < min) {\n\t\t\treturn Math.max(Math.pow(min, 2), Math.pow(size, 2));\n\t\t}\n\t\treturn size - min;\n\t}\n\t_setStyle(items, path, outline = [], isAppend) {\n\t\tconst style = this._style;\n\t\t// if direction is vertical\n\t\t// pos1 : top, pos11 : bottom\n\t\t// size1 : height\n\t\t// pos2 : left, pos22 : right\n\t\t// size2 : width\n\n\t\t// if direction is horizontal\n\t\t// pos1 : left, pos11 : right\n\t\t// size1 : width\n\t\t// pos2 : top, pos22 : bottom\n\t\t// size2 : height\n\t\tconst pos1Name = style.pos1;\n\t\tconst size1Name = style.size1;\n\t\tconst pos2Name = style.pos2;\n\t\tconst size2Name = style.size2;\n\t\tconst length = path.length;\n\t\tconst margin = this.options.margin;\n\t\tconst startPoint = outline[0] || 0;\n\t\tlet endPoint = startPoint;\n\t\tlet height = 0;\n\n\t\tfor (let i = 0; i < length - 1; ++i) {\n\t\t\tconst path1 = parseInt(path[i].replace(\"node\", \"\"), 10);\n\t\t\tconst path2 = parseInt(path[i + 1].replace(\"node\", \"\"), 10);\n\t\t\t// pathItems(path1 to path2) are in 1 line.\n\t\t\tconst pathItems = items.slice(path1, path2);\n\t\t\tconst pathItemsLength = pathItems.length;\n\t\t\tconst size1 = this._getSize(pathItems, size1Name, size2Name);\n\t\t\tconst pos1 = endPoint;\n\n\t\t\tfor (let j = 0; j < pathItemsLength; ++j) {\n\t\t\t\tconst item = pathItems[j];\n\t\t\t\tconst size2 = item.size[size2Name] / item.size[size1Name] * size1;\n\t\t\t\t// item has margin bottom and right.\n\t\t\t\t// first item has not margin.\n\t\t\t\tconst prevItemRect = j === 0 ? 0 : pathItems[j - 1].rect;\n\t\t\t\tconst pos2 = (prevItemRect ? prevItemRect[pos2Name] + prevItemRect[size2Name] + margin : 0);\n\n\t\t\t\titem.rect = {\n\t\t\t\t\t[pos1Name]: pos1,\n\t\t\t\t\t[pos2Name]: pos2,\n\t\t\t\t\t[size1Name]: size1,\n\t\t\t\t\t[size2Name]: size2,\n\t\t\t\t};\n\t\t\t}\n\t\t\theight += margin + size1;\n\t\t\tendPoint = startPoint + height;\n\t\t}\n\t\tconst itemsLength = items.length;\n\t\tconst startIndex = itemsLength ? 0 : -1;\n\t\tconst endIndex = itemsLength ? itemsLength - 1 : -1;\n\n\t\tif (isAppend) {\n\t\t\t// previous group's end outline is current group's start outline\n\t\t\treturn {\n\t\t\t\tstart: [startPoint],\n\t\t\t\tend: [endPoint],\n\t\t\t\tstartIndex,\n\t\t\t\tendIndex,\n\t\t\t};\n\t\t}\n\t\t// for prepend, only substract height from position.\n\t\t// always start is lower than end.\n\n\t\tfor (let i = 0; i < itemsLength; ++i) {\n\t\t\tconst item = items[i];\n\n\t\t\t// move items as long as height for prepend\n\t\t\titem.rect[pos1Name] -= height;\n\t\t}\n\t\treturn {\n\t\t\tstart: [startPoint - height],\n\t\t\tend: [startPoint], // endPoint - height = startPoint\n\t\t\tstartIndex,\n\t\t\tendIndex,\n\t\t};\n\t}\n\t_insert(items, outline, type) {\n\t\t// this only needs the size of the item.\n\t\tconst clone = items.map(item => Object.assign({}, item));\n\n\t\treturn {\n\t\t\titems: clone,\n\t\t\toutlines: this._layout(clone, outline, type),\n\t\t};\n\t}\n\t/**\n\t * Set the viewport size of the layout.\n\t * @ko    .\n\t * @method eg.InfiniteGrid.JustifiedLayout#setSize\n\t * @param {Number} size The viewport size of container area where items are added to a layout <ko>      </ko>\n\t * @return {eg.InfiniteGrid.JustifiedLayout} An instance of a module itself<ko>  </ko>\n\t * @example\n\t * layout.setSize(800);\n\t */\n\tsetSize(size) {\n\t\tthis._size = size;\n\t\treturn this;\n\t}\n\t/**\n\t * Adds items at the bottom of a outline.\n\t * @ko    .\n\t * @method eg.InfiniteGrid.JustifiedLayout#append\n\t * @param {Array} items Array of items to be layouted <ko>  </ko>\n\t * @param {Array} [outline=[]] Array of outline points to be reference points <ko>    </ko>\n\t * @return {Object} Layouted items and outline of start and end <ko>        </ko>\n\t * @example\n\t * layout.prepend(items, [100]);\n\t */\n\tappend(items, outline) {\n\t\treturn this._insert(items, outline, APPEND);\n\t}\n\t/**\n\t * Adds items at the top of a outline.\n\t * @ko    .\n\t * @method eg.InfiniteGrid.JustifiedLayout#prepend\n\t * @param {Array} items Array of items to be layouted <ko>  </ko>\n\t * @param {Array} [outline=[]] Array of outline points to be reference points <ko>    </ko>\n\t * @return {Object} Layouted items and outline of start and end <ko>        </ko>\n\t * @example\n\t * layout.prepend(items, [100]);\n\t */\n\tprepend(items, outline) {\n\t\treturn this._insert(items, outline, PREPEND);\n\t}\n\t/**\n\t * Adds items of groups at the bottom of a outline.\n\t * @ko     .\n\t * @method eg.InfiniteGrid.JustifiedLayout#layout\n\t * @param {Array} groups Array of groups to be layouted <ko>  </ko>\n\t * @param {Array} outline Array of outline points to be reference points <ko>    </ko>\n\t * @return {eg.InfiniteGrid.JustifiedLayout} An instance of a module itself<ko>  </ko>\n\t * @example\n\t * layout.layout(groups, [100]);\n\t */\n\tlayout(groups, outlines) {\n\t\tconst length = groups.length;\n\t\tlet point = outlines;\n\n\t\tfor (let i = 0; i < length; ++i) {\n\t\t\tconst group = groups[i];\n\n\t\t\tpoint = this._layout(group.items, point, APPEND);\n\t\t\tgroup.outlines = point;\n\t\t\tpoint = point.end;\n\t\t}\n\t\treturn this;\n\t}\n}\n\nexport default JustifiedLayout;\n","/**\n * Copyright (c) NAVER Corp.\n * egjs-infinitegrid projects are licensed under the MIT license\n */\nimport InfiniteGrid from \"./InfiniteGrid\";\nimport GridLayout from \"./layouts/GridLayout\";\nimport FrameLayout from \"./layouts/FrameLayout\";\nimport SquareLayout from \"./layouts/SquareLayout\";\nimport PackingLayout from \"./layouts/PackingLayout\";\nimport JustifiedLayout from \"./layouts/JustifiedLayout\";\nimport ImageLoaded from \"./ImageLoaded\";\nimport AutoSizer from \"./AutoSizer\";\n\nexport {\n\tGridLayout,\n\tFrameLayout,\n\tSquareLayout,\n\tPackingLayout,\n\tJustifiedLayout,\n\tImageLoaded,\n\tAutoSizer,\n};\nexport default InfiniteGrid;\n","/* script */\nexport * from \"!!babel-loader!../node_modules/vue-loader/lib/selector?type=script&index=0!./VueInfiniteGrid.vue\"\nimport __vue_script__ from \"!!babel-loader!../node_modules/vue-loader/lib/selector?type=script&index=0!./VueInfiniteGrid.vue\"\n/* template */\nimport {render as __vue_render__, staticRenderFns as __vue_static_render_fns__} from \"!!../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-b26c15e2\\\",\\\"hasScoped\\\":false,\\\"optionsId\\\":\\\"0\\\",\\\"buble\\\":{\\\"transforms\\\":{}}}!../node_modules/vue-loader/lib/selector?type=template&index=0!./VueInfiniteGrid.vue\"\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = null\n/* scopeId */\nvar __vue_scopeId__ = null\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nimport normalizeComponent from \"!../node_modules/vue-loader/lib/runtime/component-normalizer\"\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_render__,\n  __vue_static_render_fns__,\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n","/* globals __VUE_SSR_CONTEXT__ */\n\n// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).\n// This module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle.\n\nexport default function normalizeComponent (\n  scriptExports,\n  render,\n  staticRenderFns,\n  functionalTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier, /* server only */\n  shadowMode /* vue-cli only */\n) {\n  scriptExports = scriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof scriptExports.default\n  if (type === 'object' || type === 'function') {\n    scriptExports = scriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (render) {\n    options.render = render\n    options.staticRenderFns = staticRenderFns\n    options._compiled = true\n  }\n\n  // functional template\n  if (functionalTemplate) {\n    options.functional = true\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) { // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = shadowMode\n      ? function () { injectStyles.call(this, this.$root.$options.shadowRoot) }\n      : injectStyles\n  }\n\n  if (hook) {\n    if (options.functional) {\n      // for template-only hot-reload because in that case the render fn doesn't\n      // go through the normalizer\n      options._injectStyles = hook\n      // register for functioal component in vue file\n      var originalRender = options.render\n      options.render = function renderWithStyleInjection (h, context) {\n        hook.call(context)\n        return originalRender(h, context)\n      }\n    } else {\n      // inject component registration as beforeCreate hook\n      var existing = options.beforeCreate\n      options.beforeCreate = existing\n        ? [].concat(existing, hook)\n        : [hook]\n    }\n  }\n\n  return {\n    exports: scriptExports,\n    options: options\n  }\n}\n","<template>\n  <div class=\"vue-infinite-grid\" :class=\"customCssClass\" :id=\"gridId\">\n    <slot/>\n  </div>\n</template>\n<script>\n  import InfiniteGrid, {GridLayout, JustifiedLayout, FrameLayout, SquareLayout, PackingLayout} from \"@egjs/infinitegrid\"\n  export default {\n    name: 'vue-infinite-grid',\n    props: {\n      customCssClass: {\n        type: [String, Array]\n      },\n      layout: {\n        type: [String, Object]\n      },\n      layoutConfig: {\n        type: Object\n      },\n      tag: {\n        type: String\n      },\n      size: {\n        type: Number\n      },\n      outline: {\n        type: Array\n      },\n      options: {\n        type: Object\n      },\n      horizontal: {\n        type: Boolean\n      },\n      isEqualSize: {\n        type: Boolean\n      },\n      isOverflowScroll: {\n        type: Boolean\n      }\n    },\n    data () {\n      return {\n        id: Math.random().toString(36).substr(2, 10)\n      }\n    },\n    mounted () {\n      var vm = this;\n      var ig = new InfiniteGrid(vm.$el, {\n        isOverflowScroll: vm.isOverflowScroll,\n        size: vm.size,\n        tag: vm.tag,\n        horizontal: vm.horizontal,\n        isEqualSize: vm.isEqualSize\n      });\n\n      this.$nextTick(()=>{\n        ig.setLayout(JustifiedLayout, {\n          margin: vm.layoutConfig.margin\n        });\n      })\n    },\n    computed: {\n      gridId () {\n        return `grid_${this.id}`\n      },\n      gridType () {\n        return this.layout === 'JustifiedLayout' ? JustifiedLayout\n          : this.layout === 'FrameLayout' ? FrameLayout\n            : this.layout === 'SquareLayout' ? SquareLayout\n              : this.layout === 'PackingLayout' ? PackingLayout : GridLayout\n\n      }\n    }\n  }\n</script>","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"vue-infinite-grid\",class:_vm.customCssClass,attrs:{\"id\":_vm.gridId}},[_vm._t(\"default\")],2)}\nvar staticRenderFns = []\nexport { render, staticRenderFns }","import VueInfiniteGrid from './VueInfiniteGrid.vue'\n\nexport default VueInfiniteGrid"],"sourceRoot":""}